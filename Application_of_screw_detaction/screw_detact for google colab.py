# -*- coding: utf-8 -*-
"""screw detact.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I6lfDbKseePzyN-vNZJRr75n6lelnh7a

# Screw Identification and Classification System
![csm_Case7_ConSenses_mobil_16fef417a5.jpg](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAH0As4DASIAAhEBAxEB/8QAHAAAAQUBAQEAAAAAAAAAAAAABQACAwQGBwEI/8QAYBAAAQIEAwQGBQYJBQoNBAIDAgADAQQFEgYRIhMhMTIUQUJRUmEHI2JxgRUWJDNykUOCkpShscHR0jRTVVbwFyU1dJWissLT4QgmNkRFRlRjk6Oks+M3ZnN1g+KEtPH/xAAZAQEBAQEBAQAAAAAAAAAAAAAAAgEDBAX/xAApEQEAAgICAgEEAgMBAQEAAAAAAQIREiFBMVEDEyIyYQQUQnGBkbHw/9oADAMBAAIRAxEAPwD6XSSSVpJJJJAkkkkCTE9JAkxJJAkkkkCzST0xAkkkkCSSSQJJJJAkkkkCSSSQJJJJAkkl4g9SSXiD1eLztL1AkkkkCSSSQJJJJAxJPTECSSSQJJJeIEkkkgSYWlJKKseJL1eIPCJNzSTSQepkUsl4qHm9NIkiJR3RRhXak0kiK5QkRrQ4hVco2knEUVVe0/a7lVUI5h2KHvH+UpnneolRePUu1aolXePwiqbh+yrDjtxWjzKm92tK71cbK7heyqrhB+MrDhariVVzIi5fcu1XOUZFBQxUxZKEtXkrqiUbg6cxUcVJFRkMe0qqlHFNIk4huLSmkKtJuaaSdkmkMVrEceym9pSWxEU3egQ6l6mCESUmSBopw5pWR7KcIRuWNK2KkEbUrY+FOyUKOEe0nbuKjzU1tyBo5KQR0pbLVpUzYR8SmVI7k4R6xSIIdlSFkPKSxqMc+0SfBvKGd3Fe2aV4QOQGEFI+gExPTF8R9Mk9MT0CSSSQJJJMQPSTEkD0kkkCSSTECSST0DEkskkCSSSQJJJJAkkkkCSSSQJK2CSSBJJJIEm2py8QJJJJAkkkkHlq9SSQJMSSQJJJLNAkkkkHiSSYgemRSSzVhpEvUkxAiyUcVJmo7rkC3pDmldFNLNUwiJQuEnOZ/ippRtFBHd4lGRXFp1JxOqFwu0KtBrhRFU3j/FVh525D3jiulaslXmO8VRmDVh44qi8Ubl1rVxlXLIeVV3D/ABlI4cRVVwl2rVzlC4UbuVQuFHtKSKjIo2rtVEoXCt3qMiiSkJNugtc0ZFFRkUS5lIoSVBdpRkKclmrSaJW8qdu2eotXUvFESBpDFIc7U7spbyWsNuNSCMSJIRUg58VjTRG1OEkiz7SWaKOLNIRu5k0Sj2lMJfkqA3JSNlb2bk64CHT8U3epUmHvJOu8JXKHmG5SCcBWNSCUeJCnWwLl5etNbKJEpPtKQh0ivRGOZKLawEvq7lNAwIeXgoW7ukkkvjvoEkkkgSSSSBJJJIEkkkgSYkkgemJ6SBiSemIHpJiSB6YnpIGJJJIEkkkgSSSSBJJJIEkkvEHq8Xq8QJJJJAkkkkCSSSQJMT0zNAs0ks0kCSXi8uQery1epKwxeL0sk22CBpZpJ25NQeJJJmaoLNeLwtPaTe1zIw0k0su0nEoyWiMslXcOHZHUpnMx5VVeO0VVUIXo+yh8wVysPFElReLxLtWqJV3iVNyMSUzxfjKq4UCJd61cbK7hR/GVclM4XhVdzNdquco3CioSKCcXMo4DzRV1RJpeyo7o2qRzItKbbBUlCUbSUZEpiyUYirSbfC3JNzTu0kXMgbzJpCnW6k4Q9pBDb+KkQ+0piCHKRKOyAlpQIfsqRvIeyk2NxZCrUvKTDv1bJF9lRNlVqqll/vThau5etXHpKYaHN1khHvtTW2XCG5oStj1qdo9q1/SHZRErUrI9lSWRFzVzdaRDcWfZTYKzTqUYj2brlY3EORaktlcsDRGAj4k62AkOm0k4QiKcQxHmRpw2XCnEQW2jpTbdXKlZAt1q5LNuC5TZDHfAdycLFutTMsxKEShHKEepbs3V21JJJfGe8kkkkCSSSQJJJJAkkkxAkk9MQJJPTED0kkxA9MSSQJJPTECT0xJA9MSSQJJJJAkkkkCXiSSD1eJJIEkkkgSSSSBJJJIGJDqT0kDF4vV4gSS83r1WGbkkkkCXi9ugvECUVydvUaBxKMk5R8yphRUdvhJSRUa0K21QkVv2VISruFHsklUI3D8JKm9GPaUzx+LmVN4l2rVkoZgvCqb32lM8VqpvR06iXWtXOVeYjAVVIocoqxf4h+KrvHDwrtVxlXc9pV3Ch2VM5l96hc0iulUyjIrdVqjLUSdaZfBK2JbhG4vZVoRkMPEolfGmzjg5ty7pD32q1K4fnZkc9jYPtLN618yaTboFLK1RkMbdPMtZ80pgWxNxwRHrRCWw7TGxbFwidLrjwXOf5Px17XX4bMHu7Sm6KZDmIlb9mK6RJ0OlyxE9sby6gPgiAvNiVnRWgHq07iXGf5kdQqv8f3LmcjQp2d1S0uRD3luRL5n1UiG5sbYreTE20TOycvl8vDugmtu7O24i8jHgSif5dreIdK/x6s3J4Fly/lc5afHIVaZwXISzxRec2w9kC3IhMVVhqaFqb0l1OeFN2oTIlG4XRhvg4K4z83yW7XpT0dK0+mNtky5T2hKHWXFXpdiXbl7JQhly6oEMFmZqt9GFsZsrgu4jxyRBydYm6WMzLFtWIc0Q4j71E727V9osy004yTQkJF1wIeb3ISMvsJwtqQtBdm2Fu5ZUsTz8pOeqbadkg1Qj1q9WKwczTxmpQdtLu6St4tRW1pPhm8YyPTVMln5VzaS7Ql3rKvURsniCWe1QHOIEqshWJ+lj6310g9pKJb7YKxMSLrkwy9LPE7Kua2nOsfJdKWtTjKZxbnAXv2hAQ2kHGCRZ9lazokJtsgeZAJ9kdx9TkELqVIdlpcX2xEgPSUPDFd/i/kRbiXO/xa+AltqPiuUg5lzFpUd58BTt5dpehCQRhdzKTYR46VCOXiVhvIuZQ0hKPaXsRjnv4p4gem1SZR6+KhTsqSSS+U9pJJJIEkkkgSSSYgekmJ6BiSekgYknpIGJ6SSBJiSSBJJJIEnpmSSBJJJIEkkkgSSSWSDxJepIPEkkkCSSSQMTrl6kgSSSSBiemZrxB6vF6vFYSZvT0xAkkl4g8JNzSXiD0iTSKK9TIqmGlkmp6YX5KDxREKdFRkS0Ih9pV3BC265SOR9lVXPWcvN7SqqFd4utU3iV4pUy0iQF+MoXJRtv+UuW/ZXTaKo1C3iVdwvyUa6PTDLU8Q/aUnq5Ys222jCPA+Kr60GjL7KLhZCJEUepSDR5xze2zxRx6sNSwkLkqIlHtgmjVW3WxNty5qPWJbxj5p/YnqE/SjuQuVw++4JRfLYjDxKwOGmPV3Tmk+OnqUM9WJiSeKDg7Zhzjd2fcrUvVWJ2VEGHLi5YQ6xUz81+pVpUQbodPlhG1kD8yUmykJIrxlRA49ayc1V6jS5ggcZI5eJb+uGSLU+elqu2QSz1+Q7w6xXObXt23j0LFO8wtEJNdUQ/aq81W25bTN8ke2PZWVnjm6M8RyXrQiWoP3wV7ay9dp7nRm7nW97kuXHLyWYMjzM6EzL7Ror2uox/ahc5XTkXujTMv6jjE/CsO29NyM045TXitu3sEtY4784KKUzKfXt7n5cuK3Tlm/HA43UGJ+VvlpgXQhpzHiMfNASrbtIIimy6TLn1DxFAZGSnJF7pNP0Ow3xbLgSOTEu3XZcZynt7KYhomGPPvyTEZ5MzjMDHSJSs0knpIidsHNxoi1isn8tVNia+iPbWVDi2XHd1IpK0R+ScGdppED8PrW/F5K1NUxq4anLW2H9YHhilZryYlDObSt0UahIa8tL0uXOMe9UaK7NyL22YEiGH1jZcCFGBZ6E83UqaNt+l9vqKCPNy7UyIvSltgcweKEepTPyRhWnLI1ySYqA9Ppt2yj9cx4YptJkZilON1Cm+tY/DSxdqHWtJLysKbUNu2N0q5ucb96r1Zp2lk3MMCWwcLf3Cp+rMwacqNUpssw4NTkBvkH95N/zceuCqiEvSZpmZkvW06Y0vtdQ+aNUkdTzIt3y8xvy8JKu5JHS5y226Vc4wLsrJ+WW6I6lTW5YtswIvSTv4Pw59ahlZI5K4NtbIGWbXsxitRJykPk9xkdTXFqPhhHqQmUJu4pV7WHZuUzdWq1KutuDsnRuMOEetXhl5eecsHTmNpQ8SG1gehbF7QAbsru15K03Ottt7QR4jdC1ItrKmPq0r0aacFrUF26KpiJ3LUVplp+R27WnPseazIxu5tOS+l8N94eS9NZNtjd2d6kbAyL+FNttElIzndmJWro5rA5iXN+UnXR9lRkIdoriTxYCIQjAtyl0diSSSXynrJMT0xA9MT0xA9MSSQJJJJA9MT0xAkkk9AxJJJAkkkkCSSSQPSTEkCSSSQJJJJAl4vUkHiSSSBJJJIEkkvLkHqYnpiBJ6YnoGJJLxAkl5clcrDSJK6CWabu7WlArk1N2rV2QuCRd1ypzlSl5QS2hXFDqFBe3LxCG6/JuEIXWkfi7KjnqrMS2/ZiQdRjwVJ2GO0lmsqWKpZwrJu5kfGKp1CbcbHbsTROy8eBj+1DZrpiYbYHN0rVXbqEu6WQuDd7Swvzti1cE22LwfpU00UZ2V6RTy2rUeseIx80Zs2E5NxabGIt6Y9aHlX5drc4JCUStzWDcqFVkSICF2yOmMC3wy8kUl9lUGcxc0xHf3jHzW6py1E1Ujb1tPCbXVEUJnMRwbG2ZbuGOm8eIoC81O0hwnZYtqFuoC3wVymnKVaRLTrhxb6xW6mV4ppt9vaSL21a649Yx80NmK1PyLhA43tZePGBIXOSj8k5tJArc+IeJaSlOt1uikbX8qZ3OsFx+C3VOxMmxPM7SUcuG3eHbBC5h6fpr17ZbVrtAXBUykn5SaGakiJp0C4dReUVpr2a7TSmZYdlOMj65j9qrU2D6bMS9b6Qy2JbUB5OsfcgL0rMyLxGwV+RbwL9qIFT5th4Zyn+qmA3wiPaR5yVarcmNTlhsd5JhrwknGU8q9HmmK7TXrW/pDHMwXH4IHOS7ks90mn3NOh2EYKmTEpMN1CllZMN8YdRQ7oo8LTFQbGfbbt2ml0PAXWs2hWss/KzAV2llGWuCfZ0vsF+uCEs0WdlpgZ2llsXwK7LqJaiepvQnm6hIaHw5vbh15rRSOwm5UXmNTR7/ion5eFVpyz9rdblW5wR2M1DQ+1596quYbORe6fTysmA4w8UOuCNTUhCWqQzjXLHS6HigikwBi2Jtah5oKJ+WcQrSMsn8kSdWuelmyZft3913cqcizGSqAzLA2TjWl1rqOC1kuEWpq8R0nxDz71TxZKbMRn2Odvmt7UFM3bosTFPlKhJjMsaCjvhbxGPcqMxTehj0qUK2Y3CVvagiWFrHZVx9orgPjDwxSni2UwJ9iHHuyUzbkrVeFmDsuLrZDy74j2kLcZCWnBjbc05ucb6veizJttMibf1Dn+aqMwcGphuLmobv0JM45UovDCRetLew4W74ohQ5eDBORb+qjx96r4gZgNvgPeMfem4Wm4DNEw4Vwnujcp8SLU8GwmBiOpo0QqjMu/TRbtuBwfyYobVC2E05LOachzGKmw9NhPS70qXPbpj5p4lgTh7ORmujv8t26Pki2ImgbIRL6o+ES81k6w87LFtHNJsnaS0Ew9CrYVbd/Cy5QjD4p21JhiaAiKTIrihp1IHVM2Kk8wQ2GBRKEPch5TTspiCVc5ReGG/zWkxJKOTsxJzgjrcCyJqf0KO2Yq9LJuZG4ocsPchcvO7AtmXIHV5IfTCfZqz0o2WsC3Q9/Urk5T3CJ4y0utlCEQ8upVtwGzVTbYcek3C46h+Kpjs3N5DaXXBZ/GzLrTMnONiVwFYUerdvR5s4OycrMj/zhqBx9/WvX/Hvy5fJXg6wBJTNnAeyq46t5K42ACOa9svOde0Q22pQGOW7gl6u7l96nGyzlWKdYSSSXy3rJMT0xAskk9JAxJJJAkkk0jAeYh/KQOSUPSm+yVyRTHhFBMkqLzs2RDsLBHruQt6pPjMEw+RM5cDt3F7kGiUZPNjzEIrn5Ts+7WCbmduLAamnGs8i9+atTVTqDEwUXWWipcAzccMvWbu6EFeplqJitSDDljj1x+Ad8VI3UAdHNv/OWbkWafUpEZyhNi9tPwhFvH3psxh+qTdozNS2LECziDQ7y8s01MtYLxlzJwzEO1pVGTYiw3aThn2YQLsqRwvESap2ELrkkJKeblCz2w2dcEQl5huZZFxorgik1mqq2TJJJKAkkkkCXi9XiBJJJIEkkkgSSZfAeYk3bAgckoSmICoymI2qxaTboKntTLl+Ka5MNtDm44Kamy5eAprjoITMVeTYG8nLh7hQt7FDAl6sbhV1+K1unOflivbUbWA8ydtQtXP3sVu7QoC3aMeCpt4qnWnCuETHrh4V0/r2Z9arpG2hcqM9Luzd0GpqzPgBLGs4zMh9ZL6lcp2KoOFbMt3NR4RHiKmfht6Z9SvsDrDUzSJornCaOJZ3+JUZHG7EtPbCsiUxKn+EDnGK0lcm+ms9GmbTCJepf8/DFZ2qYckJ2RzcZKWmALfEeCacM35TTzQVBwvkd4XmD1Nnd+iKG9OrFELYzouuysS9Y3xgUFn5F2cw3PORFvay57o28PeujEcahS23itdaMeKamwWzSqfWRKMtOFv3wh1h5RQt5qo0Ca0/SJWPMHUUFMzIP02odMktQQ+sb6igj0xLxm5MZyWEiYcK2IeGKrHKekcq1T6zSyebl7rOIdsPeg7krM0lwpmReIgjxb6i8kYkafM0ia6fLCRAe55vxQRicpTT+xflCul3dUYeGPcpzGW6yEtzHytS+kyw3iGl1suLcUDEJuUe6VT9Jw4h4ody1BU92kvDMSXLH60PFBXBkAbeF5kbmHd8I/sTaG6yos2VSl9MltJQ0vNFxbihZU9yWmG56SG11vfGHih3LQCxCRqG2Z5HtLsPJFHJWDDmnUEeEVO6sAcxJNVBsZ1gbBj9YHhioRp7tPeGcp+l3tQ8UEYbslJwiEbgMciAf1qaYHZFaXLxh7km5qpvS7Ezs5pgdDnNDwx61D0KMlNNzstpOG5yH84MeKvUTZuNvRLS11wHvSnC2YkF3xWbN1TPS7Yle2PqnN8PiqrbUZGaJ6WH1T2l0Or3ogy7taeJCNwQ3F7PmqolAuX4wU7N1WJwAlGbm9Qx4KvRwDbOWlaDg5lDqz71YqQ3Soxb5e5V6bs2JhtweWPFNlKdaegw4MC5eVXKE8Dcj4QiW74qHEQNjUBg6NzR74R8lappttk20QgQHuy9655asTRQfHL71aKMG5NvZ6RgNvxQmeiclPEwXwj4lNInCZ2zDhWZjm3EuyUFNfOFftIMxa4J9lSVCYhtHIOD6gx/Wg5Om2WTnNBXHBB+kuODdtWy1e1BK9wmfYHh6pfJeIHpAvqHC3Q96OVY4C84z3isXXmnJapS8z2m8t62k0Dc83Izg8zoWRj7XUnQq0Gfg5IzUq5qyHMfgqbk3F2T1XbuFyhbiclVBt7fUiQyDjZTDL7epz1g+zBKzwSsCcalh23ty+/zy61nbnZSpNny5rSYdGLbxMlqExiEUPrkvFuTE7bTZOIxU9KGqw105mTmh5ojYXvQWlkdPrA6rdSMUybgVDKJahDKKo1oLXGZgeWKbfans6vU2EzMT0CHnGBiqvo8di7LzEm7q0xCMFoHrHW5N7tGEWorK0V35Pxk822WTR74wSZ4iTtJiSQgMiy922D/VFHJd3pdBbNsrhbID/eoa4DZN1Jm7SYwMYe+GcUHwZUg+S5hrlKAxDUk+YV0r4iahI1pmda07TKMYooRg7VNQ/wAoY3x+zvQPGU7D5JlYlqKHWPko/laJfJrxcm4IR+1uTHMwnZTx0cRocxLt8kdf6ckDwpUIzNNblyHXKumGfihHgimLp0LXgHXmERhBYvCEwbNSILrbxAvvXb4ftwm/bfNs6uW3NXLYCJD2U1s4lzc0FJuL48V9KbPMay1Dm5VNAYxhncmiFxcqsQDdyrNlOnpJJL5r0kkkmIEkqNQqspI7n3NfgFZ2qYqmTZKFLbaA+o3UGwVGtVJikSJTM2WmHAB4lFcnq2IMcsMuONvNTDX/AHQ8sFh5jEEao5bVnJqXfhwcEoxgPvhFBtMSY4qFScIGJ4aYx1B2/ihMvK1Wd9bIYk2rvgIkBmBm5ZsTmW2qnIHwcH/coW6bB/aTVAeIH4b4y5c45dyvUbBnFmIcNuCNfldtJw4vhv8A0rpGHcRylWlRcYeF0I9fh965LhrGRj9Cr7d8ueiJmOcPjmrFWoc3htz5bwqRHJR1vSnHd3wQd0HUOlOLIhyWDwljCXqVLbeEreoodYF3K9OYni2RWjqhwV0+Kb+EXvFfK5OUeouTV7NWd6PEt7BdytDTac0ObrImUOs96xc1iKbcLIXCEYobMVJ0hGAuFd1wuXqr/Et288/yYboXaPS5p6YlLWnXB1AHIXwVd7FjA3D9ywcwZnbAebrVcQN0uW7uXWv8WK+XL+zPTZTGK3PwKCz2Iptz8Noihrck+7p5cupTM01x8REh4cNK6Vp8dekzf5LGlUHXNRFcSNYaxKdLnhCZvKVc0l7PmoZXDUy8Ik2377kUl8LxEsuJw4qfmt8Vowr4q/JWcuiNmBtibZXBEc4RTln6KblNcbkZn6o/qj8+5aD7S+XaNX0CSTSebHmJV3JtseXUpFgigI6uVR9Ib8SGzDrjpc1o9yrlYPaK7uFVqDHSIdkbk0nj7IoHtXLbhK0e/rVWarsJZy1wfdFbWm3hM31aApg7uZRk94iWPmsTuOD6obRQ8q1Ov3W3Cu1f41nKfmhvHHm2+ZwVReqss3+GWHcmJtwfainN0+Yd+su08F0/rxXzLn9aZ8Q001iVpvc2N5QVF7E75fUjaKGyuHZl14TuKzrBFmcOHdqK1bj4qmfksFzFanXfq3LeyqJTE445qIty2UvhpoXL3NR9SKM0SUb3k3cXtJ9b46+IPp2t5lztuUmXy03EMeKtN0CZIS89K6RLyTTWkWxtU2xgPKIrJ/lz1CvoR2wsvhVwvr1eZwqw3zFcK1wsQ7WpOtgOlcZ/kWs6V+KGTewvIXDs2y9pSM4alGyuEdS0ll1wl96rtjFtwg5hhwio+rf23SPTM1CiNgVhFaw9pz8MVDSZe6acp07qfAe12x6orXTDQTMuTRahjw96zc4J9HbmR/lsidpd5D5rd5NIB57DDfSnGS1MHwihtKkn8P1TozuuSf4XdmK6Iy81NyrZt9vfD3qjVJJudlci5odaiflnPJpHSGTprV1tuiPBV25X5LnHA5pJ7iHhirlPKLRdHdLVbmNysTjsCZ5bu9TN5yrXhI3Ltk3ZzDHh7lTlWeiOOS5amHC3ezFSNzDjYjtBtGHKfigpidAiG7lip2xKtVeaa7JdWlOl2bZMgtuCH+aoahGMkQi4VwR3Qj5R4KNubPUAlz7oqthXmB9ZmWoeEYIoWfyWN2qzlWfemNnNE0XNDTH4IxSnYTcu9LEWqI3D74JlijIlbNbYi49SsYqHZy7bjJdnOEUFF02nHBLTq3ftRhwYz1DeHmdZ6vZVAXSZuNxQEtLm6PxU1QByWcEHCIx5YmX6ENlWosEIF9qHuR6pBCepsu52w0R/YmzNUeGpuAuPSzukD0qrNHFieeDsXZwVFkTbe1aS5UcnpQClWTuudMN0PcoKrVLPpMq8BaiAYxhBA23Yjp7Md8PcrlEdOWnh03DHdFOnpTZOOCQ2ZHnCHlFYpJNNHPUUT7cqXHxQiqLN4lldw4I1SRubeZ/nAtVWYYtEY+zb9ymbKqtVIOmtszHaiNsffBD5MLiES5oItLhFyk+I2yzh7lREYDOFb16oKZ9lUlQkm2imAHq1j7optJMG23NpqaMbSViaK6aZfu0xCLRQ93BCZM9LwF4ojkq7Sq16SB+l7QecBiMFcwvMbfC9hajYOEYez1KaYL1LwWjbbdCPvWbwhP7Campa7TEt8E7BbEg7Ocbfbts3RRxt2Drcq9dcRjYs/iaYh8nlAR4AqdJq0BkWRc6sihH9CVryTYebKMtPX8uRZpVh3ajNQt0mN8PuQOqVJsahaRWioXqrbpItNlsIpWvMwmbcHUObN+hzDRc+8MkQrE3bRWyLSYDDOCwdHq8emTku0VpRLcm16puS1PelyIi1XQiSVpxME2dAl6r/AHvZu5Ia/srM16oAxiaVeactGPNb2kFolSmH6O85d6plqN0Fma1Ovuz0uY3W3boqtPsNuYdWmqx9IeNy+1xqIwPqJZHC1Yh06alvGVqkqjUw7T6fs7rojEYoDhamvjiwWi0696TWMRLMzmRLFlVtp5So3aCjFUabVTdoeX82UChH3I1WqJ0maqEbtIZ5LP0mV2dNy5S2sBj7UIxXTjMJrnlRqVTc6RtHOW2PN7ksKHF+oSLwiVphlGHuWoxZQmPktsxG0oD+xNwxSISTNPPmLYb+5KeW9NRbEuYbVMIQ8PuSG/THmUw3/i+yvc5FsoDbG60lbHKyGcM496gEXe1qGPBTWuKVOkpJiS8DuSH1ie6IyWz57eJcBV5woNiRkVogOcY+UF88+kLGUxWag9LSjhBIAWULS+sy60Gwnq9RG5oul1ATO7fbvU0nN0qoDZJTTTpR6utcPcs1EXMoW3TacFxhwgOG+ERLJB9ANyrrG9orh6wJBa9huUrLJGwIszn9uKA4Mx6bjzcjWy45QbmPPzW4qAGNszKaihxgP4SCsctb6Zh1wgFu8I7npct8Ch5KxNMS4tt1OlvEI9UOsC8MVuKlKylZp5Ojzw059Yx81y3pp0irEDo3tXZOt9RQ71tQaeJiry5BsRaqIfWN8IHDxQTqLiSboRdEmS2sr1Xb4hDuQmuHFom52SK1qJZtOfsinVSYbq1P6fKNiL4Da+3/AKy6ap2FqsYUSoN1ujCR0mb0zTQ/gi71pJeYCebbNkhPMcxj4oLD4OrDfrqbN65V8bSAt+7vh7kQws6dGxIVJm3LpeJXy5+XculL/TnMeHO9N4x21nye+7qEdMFel6A+7zN2lHhFbyQal3JVs2x4jvV5sQbG23h1rpb+XPTlX+NHbGyOGIttlFwfiiErhVoRK7r4W9laoWtOnlUcxOsMPMy7rgg69pbAuJZdy88/yL27da/DWvQS3RJNgcxHXamzgSdPlelPjZLt7yjbnagdU9JNGkqw9IOS806TGl1wBzgHvWqE5aoU/Nu16VmA48YFCKjebeZdNI9MjL+krDRVJmSYedPbFZBy3IBjFba20tI6v9JfKeMqOeH8TTUiQ22HtG4+UY5wy9y+gvRdiUK/hmXN1y+dl/Vuw6yhDhFc9uVa8NJOS+3lyHlKG8Y+GKFt1CNtj5FtYcbkcJ4CErVi8bSTr9PKZlCMXW98QHuXStdpc5nUYcm2h5nBgqrlXlmrrnrlycalPlpcIveSsN9Md5rl6a/BHcuE/NPUOgTGJZdv6vUgc9i1xz6srEFbo82+Xa3opJ4Pff8ArBtz6yW6/HUz8lleVxe7LOZzJbYP9FFKlVZOelW3Gy+HhVgcENNs5OWESD1LDDkkROSxeqt3gs2pnhWtsctFT6B0tsZgSEmo79KMS+HWx3uFchfo6n4bFyQe6tQ3LcDp02rjf5rZxl0p8UYCW6LLjbc3crTdPbEhtbyGCve0SVy5bz7XrCvsbXB06O9SWQItPKlcF2Yp18OVTsJBGFqRDAtKbcmi7Ei5bR71jUw8urUm9pRk7aoRdcuLwoLREmiahJ63cRalXKaArhErSggvFyoPUCcaeGYbI7Ic0FMU1p0kqs07t5VxpsuI8UBBt4CEYt8sd6zeJno02rMzI/yebHYuezHqih44oYa0EVhBuKBeShxVOhWcMzAsF61nJyEfcrClZ92WlymBc+jsla5D48VoJepsPkOzLQ8OcFi8NTEJ2VE3dTE2NjkC4XQ3I18nuNNti2VrrZboDwLJTfwyo9NAD8iTrf8AKmNUIj3IfK1KDu0EuaHV70pN4xctc5I7oqEZAGnnha7GqHuiuf5QrsScdg/R3B1EbO+EB7o8UHbnjFm1zsdfkrVPdNiaHwnuKBJ0xKQJtzyKIp0drFU/vhR5eZYK4mysL3RQdszacG5GKGHq3pYuQw3fBUZiVi4zqK7uiPluSZ4yqtVysSoTPR5trnMNXvgqdLOLE42RdklYpbsfk0oulcbLsBy9nvSmGoNvEI9Rfr3psG1aStnJi0dN20GPlHipKGUW3iDxjEI/FFpoYOysq9zfg4/FCZcoMzQx7iVbJVZyVg234ibKMIq9TQi/T5hsStK2+HwU1WICmHoiVwmMDy90FRpc1Bp6263sxQV6g1Btxs+8YIsyMHae2fNYduflFCakbZM382qMP0qNmei3S3mWBu64fBBYGOzmi8UC4IlUnW3CErriNq77MYLOzU3bMC4PbGH6lMU7ApcolpICgPwihsISE3AXBiJXW8U5560XhIrhA84Q8iWVl6gDThQu0xJWJqoQFkjH8J+xNTZoJGdtErS+Chem4C82ZafJZHp5uCQNlaUfCqr1SPYj6y+zjFJrwnblrqhUrXGxHxZqiNQgM45qtWdbnzfk3nS5g4RVEjfJy/l70xxBlphq7gzEwLvJEdPcsjR6gA4imBIi155oxNNTD4yYDyRC6PvQWlyEW8VW+zdFVOE8jVSrBv094BLTDMULoE278nvOfzY9pGG6Zt25o7bRi6f3JsjTOjUOYtG6/TGHxTMZK1lnapMTjrzNw6beKNT0q+TNPMeYxiMYI89R2ibZjb2YIlOSQNNyP6lm33NrXhzXD0g4WJCER1QLOMEYrEgc25PHM6BArYQLs7kew5IwPEzxkNpAUEqhk6VQi9zROMVFb+WzUPwxR4N4ZnNN97UcoIbVKPAnKaFum5b6jjBrCbzwjqAFmSmGp6oSIN8zeuPxTb7ZNeYGp6nty0vTQHrKOaA0oW2K9PThDdsTWixA6bE5Lg4WgAzGHvVH0fC1POTT03aTRlGMYF2oJP4wqvmVeadB2RqD4/hOKq/J7Q4fk426onCOfmqM9NgUmUs3cO1fjAYD3QiiVWmoNyLLLekW8h+9VPmE17Q1x3pbLcoI3Z5DH2kUZlISwjp4BAIQ8oLP4eacm642I3EEC/QthOAG0sEtMF2+GvJPhVEdOfKKmbKPKmthDslpUl2n6tepwSZnw7Kmhw3W5KNkYucyngzCEMoieaxToCYkkvC7ue+mHEEabRRkJZzKYm+aI8RFcBcOHZ5VrvShV/lLFU5aXqmC2YrFtsG64IkWyGPbJA1x2H3KuTrd2VyLMhR2CIPWzbvLmI5QzUxU2XmW9Mrsih13b0TkF7K6Z6NsVbURpVQctOH1Dhdr2VztymRYJ4W3CPLfkqsrMOSzzbzRWmBZw9mKKdqrUx8lznTGx+jvaX4DwGMeBLG44kIOiM5LdQ77e1CKKUSthWaPnO6jD1bweKHegL025S5h6lTeoYDewZcDbj+5dKsUcMmE2LlOfLQ8MSa+0oaKJ02qE1MiYhEtm5AvuUMiy/KE44IkQRO9pzzWixZMSbkrT5+20pgbHLe+HXFVuzUHqFNfo1abfYHhk613FDuWuxVKsVDDMrXqbzs5Hp4j1RFV5MYVnC5BddOSPLEuJCnYCmNqM5SZnVLzYxiMC7JJNjV0z0aVsKvR2yu1w0l71urYCPiXzz6NKg5QcTPSbhFsL4wy8l9AMvQcbE+zHfBc5Umut09lZvHlIOoScrMykwMtUZJ3aS7pcM49Ufeij02bb2pv1UNJKxofZG4bgjwgSljneDMF1RicrFSrrzBv1MLIwDfAc+tazCVEhQKHL00popjY8DLuUeKsWUrC0qLlSeICP6toOJZLP1D0i0xqTps6Mu6chPFZB8csm4x8SNA/TrQITNNbq0s2ROyuh0/ZisT6Fq3Cm4wGUdctYnAiEfZLsrtlWCFWos5JkQkxMMRyj4t2cF8s3TFKqxDyTEq7x84LZK+n2BZ4vEq80EGxciOoYjqQeh4nl6pQZOdHncCEIh5w3J1SeMtm625kPah4VWzAtmmSjpF6kbrkelKbKNtjG0ULZdAXubTHgiTZXaeyt2n2nWF62Wbt7OXWpGXQK61D72xHTqUzMxaWTg2rGrX2tJIXUJcHBvEiIv0K4U0FxXFah89Oy7Yl6y7yFGsrUqrKUCqNxK3cUCjEV0qRnm5yXbfYK4DGEYR96+d/SER/KjjjYumLmqEerJdA9ElYi7QegzblrrBXN95DFLsq6Y5MNiVpEm7W7l5UHmJqOzKIjw61GzPG5aIldmoUObWAqMngQtwZhwrrrRj1JNSp6biK5BeenYCOlQvVMG7eyo25K7m5VI5TW3RES1DBGG9NMm7x1d0FC3NTDreZDYUepEBlYCOVtowS2MB5lmzQ8SfccLSW5O2B9oUS2ULk6y3damwHssXbyHNTDKgN0RHirQj6zTzdak2ICRFcg4j6WpWFNrTM0I2tTA26e+Ck9GEwE9NTEnM6hcCI5EtR6a5IHcKtzRc0q7f8I7lz30TTsCxJbbzjmMV024Z2PYY+jStYkHOeXdicO8d63lGd6TTZd5jULZQJy7jv4rK1JqEl6Qqg3yhOS0Xoe+H/APxFvRxVW5uVJgeW6P6VzaNTUra4Q/cmsux+UGWnN4uDZn4VcnDhb7VvFAZibBuYbIuZsoRgude4JXp4ICSdJsbAnGicvzHaQTag9ArhHm6ooXL1MCqDMLdcc2ij1d6qvcAxIuwanhG60YlbmnXQ2JB2mziH370Fem4cR5k0qk22JCJXEY3x9mPBTFeCbciTLuwJw2xuKIxGIeJN6QBi24WkjHfBBxqFrmktSovVP1lolaMCVVr9pnlqJip7CV2PNkWeaHzE7DbFaSBlO7Vty4sshQ8Zs3BzH71WOITnlqnJ6JcznYiMENGoQFy0i4oO4Zk2zEbrolaoWQcN5vsiqmDIxMVCDbcwyOnIoR/Qq9PqB7bLXvHgpKpJAUxa03aYDDaH4oxUcjJbN4oufZh71naeVF6oGVvlnD9KuOPOFT87e1DJQ/J8di3cOq6Of3os5KmNNbhbcF4EUfKC3PLcM3a4Uxd3o1VAg4Mqw0NpgGcYq0MoBOXCOm5XHmbZwitu0QhBNm6g9JlHBnGyLlS+TIOk9p4mf61qKVK3TA9ooCoWWoE4QkNuqMdK57cKxyAytNi3IvQIbguhn96tN08HBGOzt8laqxRZpb2z06w5feiEicNiN2pJtxBXyCs3/K2xIbWm2tMPElJyF2KCi2IWwBFqxYxPMxERHILfMkLo2VXmqgYuE0NtsDHiOST0R2vSOmXeB1vVeecFY6O2VJIO0fC370FbmIScm4JPbUYlZA+skUmJ0GsO5i5acN6dnSZx4Nm2PaSxVMdGmKfaQgEA1XLK02pwmZ4RErgbK1VfSVWNp0dpktZjuh+hO8pr4HsJVJsqlMTZckTtH2kFxJU9lVJqXb1Xlklg54JaRIXCtEBvKPhyWPKphOVx54S9VB26HtRSteFTLrU9N9BwPbdqcG3JYnB03B+sPOO6gZ61Rx5iKLOHZdkS1vlph5Q4oLhKpbKabBoSO/j+2MVWvDGy9IVbAnBJpzW4FggrFCmwkaCULtUQ3965PWKuc9iJ54SuaArRh4ckWqlX6Fhm/aetf0CHXl1xVYBKTqrTtQ6QRXNN6W4eauYmrANDKi6Q2nrhb3LC4YE5mYGAloAbnIlwGEFpMN0V/E2IHJ6bbdapbGlq78JCHBVWs2Q6JgwYy1J6W4NkxMcsPCKLWxIrhG4YpMtBaMOUYbhUjjER/CL10pFYwibZJsLuUVYsMdxbhUbYeEtXerDcDEfrLh9pJCZC3tKeAnGGdyiHVvU4Zb1Km1VepP8ARqfNP/zLUT+5WEDxtMdGwjVD72oh968bq+Yak7F+YcLmIzjH74otjCVjLUenmI2m2MIRt80Hlx21Qlw8Zwz+9az0jCHRSBvkDJVVN2ZwQ6x8rTEJ63o5tbvZjBSVSpgwy4bQ3BAt0eskDkWDmRJlpzZGfA0eZwq648yG0J7IoRjcsmOU1Z+XarFXmCi3cywe/PhuSnpJymzAy7pX574RXVmaLLyUqJ87vWHUKw+IpTauOGTdhcc1jchNKn3JF4ot8pjbGCLVKYjV6DtGxunacV495NR4w+9Z1vO7VzLaejzDszPVApxtwejwGxxvxZ9SqqwegTrszIzEmREQfWN6eWMFosNMhVJGYlZtsTajvGHhKC6BhDDEo2LzHRxEo7s+tc5pAnRMYTVLdugO1jld3RWh2EHbqlMSzN17eYfaySp7oSOMtgRWhEr2vZ74KjiA3aBjjIdAODCMLe6PBTekAeg1Km1IR0PZHmKA5VJGLeInnm/rYDB6EB7Q9pdWwxVYv0kht9ayMByXPZh0H2aDWG9wRKDD/wBkuK00jtJGYHY6c/VF7+b9SEtt0iBCIlzRFN6a2I6i4LIzE1MuaG7hLvTW5ebcIT9bv4oxn/SsP99KTWxlemy8rmD7HHTHrXK3q7F2j1KhyEq69KzD+0l7hjm2u/M0iYcu25XBwhBOZw7LywjFqXY2sNOYjzKZiG1kDwtOzEthuRZmbifAICUOtcl9KlN6FiIplsSFqaG749a+gJOmy91rhDfd2eCxfpzo7ZYVZmWR1sOwG/yJZ0V8sr6GJ+L7c5TS1EBbRv3cF0waa+7cFxWLi/ogm/k/HEjFwvVP+rKHlFfTAytrlojpgsrJNWDqUodPZbO7SBb/AGVa+Uj2du0u7re0tJVpFubl5pghuJwIh9nuXGcHTr9PxFMSE64TotnZq374Lox0aXnX3B0t2/aUL0xPkWQ6UQIzMbmx48IiKRSrrm/lTZmoT0WfdLNwrc1JL0psXPWuGV/UtI3KmTdpeHdFO6A0LY3c6bGrI4wpEsWH3hYb9eAbork+Gqm/T6xKuOFpgcBL9S+gJ6VApdwbQIYjvXz/AFKV6NWJpoR+rOJiHxUNfSDbTbjI6dMRuUjco2O8RtVHBk18oYZpsyRXFFqAl74I5uHmWNVxatFLZXEP6VYIErbUEZM6dPUnMhG4ruotycJQThK0kCc7u9NEIEzk4mvHC0tSri9EW/WFw8SCSXC1whIfcpL4cO5USePpQ9oVIR9fLmgsEcNoNpao9SaWQjbchr08wxMCDhaz4KZ6aC0tWlDYJx40EzhOoNkN2jdBcF9HW3lMRMnboArY+zmu0YoqsTorwNarxjAo+S4nRKhFqrNi2PA7Yquk7OpekJ3ZYgw/OD15tRj5Rgsz6Nqn8n1yoSrnLGaMYfenekKei63RYiXIazuH3T+c04Y3XQO9NWbOyVioQlniAi1LMzk1tS2w6hDih846/Oz22K626MPjkrlHlXBkagDmooBdBTjWWZ2SFV4uE3q4jBVZebbb6ZFwvW8zXtR4JU2lG5LsmXNEIbvinTlKD1JFz37k4yco3JgxEYl7lG8Tjk5a3fvDf96MOU2DmnuJTdCAZgY3cA3Q+KVny3UHbad6QIim9FuecPs3b/ej3R9k4LpDdkKryrV24R4nnFM8N1C5OUN9uYK3UAxjC7tK9L02Gx5eKKC1Bq23lPcUFIyYWl2tSmbcGvIf8m+pZ9gokq8m1AnhuHSi05NwbbIRHVAboRVWm5EQl2o8VXpS5UBAXHIjqzy/UlLysHWy+znC3vVOcduqGV2nmjD3K1LnApN6JOWjAeyp7OlMgj6uBFqhxuVohcalxi8PqIluj5oSM1A7TLliW74K1iaphLYfZ8USglfMnSwyYOPCAqxViBqeHZlxGGcPcsvR6sBTTYkV3CKq4ixA3LVp4XCuOI2wh71WODLdUKaDaTD3LYEeb3IHJ1C4iPlGJbkHpdYtk3ntpaADGJe0suWJQcmBiPJdnCCa8YTs3GKHQKXkYC5qM94eJWpWdBtwQutWBxNiIGHqe7aV1ulR0iunPT3ha5ox8Kasy1mOK30ScvuvKIZNw96q4SnujSbgXZX5k4fhXMa1WzqVeemBItkBWNQ8oK5OVhyRw+40Jetm9EI+EVqmimsRNTcxY0VrTZboeKKtYurcZSgybd2p/hDryXOaSXrh2hWhzFHyUNarEalVCiNxMN6G4eGCDbYeq8ekN7IbhQHEVbjUsROPj9U3ob+CGlVwpdJcZY/lD425/wA3BCaaez9c9yQ3xiiG+mKxGm4XmDcL1836puHXlHjFZuhlc8MbrQ4xj4YIDPVN2pTwk5pCGlsPCnVA35aX2LWm/mNFimIqxGqVbNrVLtDAG4e7rU3y18kU0haK2cmBsh7I9azNPmgbcEHPvVepFa9ncRlHxIgYkSgx650tENUfaVxkajiipZtS/qoDaMOoYILSJratkw9q7kewtU36XUB8HXBVVTpmDKVT6fJlKut3zDm9yJdryW6lRAWxEeWHCA8BWLmrHZdualitO3NFsNVXbtkBaThxuXvpjXh5pznlprTLeIqS10rbRuThmI25XCSsMncSyZdDWWjEcyElMJQ8NycLvsqRsub1a5qRiUeyIipoBDLhn5pw5l2VLCMYQyUtatZH0qO7PBM9b1kEFrlifS7/AMi5j/8AIC8ro4Ph4Lqw2XNkUP1rRY+H6HNERXaoZILhAL57IuWJwz+9EvSJmJTDLepgC3RLiqqiWBpDuzmhIuW5dkw4cHKeR2649a4zTsycGNvAl0jDVSiIi04VufFJS1E4TbbeREP7Vj68y4+TkW7dktFUpiUEdoRXZDugSxdcxA2LZbASu61Iy7wbOYs7+K6l6EpoBrjki4X1oZwh5wXIXpo3Jy93TmtpgapwpWJKbO9kDhd7o7kdavoJuX6DWi7Iua4fHiuW+nukRp9ep9elNIvja5b4oR/cuuYgK1lmaa1bMvyhLisz6UqadZwDNC1bt2B2jdyKq47j6+r0On1VkfWtaHIj5cE0ZiFfwO4EyJfRCuhHryju/WpsLfTsNz0g/qMNcIeYqHBTBy01NUyZ0i4MRhD4bv0oL3o8nYz1JmqO+V2X1fvgulNjEilzcLTMBCP40I5R/RBcfw1KzNCxMW1c4lu+C7I4V1PzH8Ae0H3FuWDXS8o2IjG0SzHtKwLMBHK1KlnB2ny7nN2fuVq8NpbykiUIy4N6+XIVx+qY1nBZxWy/MNMuyhWSsOEco9a6xPNTE85sWi2UvDmj1ks/ib0cUTEU43NTbZMugNhbIsoHCHiSSrkeDnaxRJ6gz87OOzEvVyiMWzLO2Oa7FjSmxqGGZ6TtuJxqMR98FeHCtI+h3SYn0MbWLuwjghBKwTL45oUxGn1qVdLSTT8M/hHJfYErMNzLLLzZXC4MDgvlf0iSPybiypMjpGDt8Ie/evoTAU1CpYJpbw88AgEY+5TXyqfES0xBa5evn/ElNdpHpS2zjnqnnYPZdRQivoC63QWoh4rifppDYYmpczqLsrp0jt1AXpdyRbJsrfIVM2UHLRbH8pBaE8Dki2ZDdmMES6bG0bRty61LRJtlxRvSsC+seyFUyqH/AHmpU3pqJEW0LSgJWS4iVpXdlcH9ITXRMWE41pz4rtAzQC2N3UuO+lh0HK0y4PWO/wC9VVMukehipQmcNvSxFqYdju8orfEVxDDsrivoMnoNTFSZc0jEYRgurOVBse0p1VsJOOxHtKNx2PG5CXqq3bqJC5yuxF5kGOWJcVWqdmqviPNyqm5NmThCPLDhFZl6umJEN12SovVtwh9XyqtU7tp0qAjm64KE1aoOXZtkJD/orKvTbj7eREX4qFslNlPE2TjpBEb4XJrBu1kriWJ3C+NnZzSmK/Bu4Wiu7kBbkn5nfsyHPgrQ0R8mxi51dScGZNGqu2uPaSPqu7k16pPv6rtEBRSTw3c3m51qQqU3JNlczcMOtMwzEsvObdyReDUIWxXOcPS+0rjZF1nvXbqtJS7VFcet4hHO5ctwpKXVZsiHTduSbNrUexlT7Zel3N8X4ZH9yH4alLsXViA8oblsvSAIDI0kB/n4F9yyODnYFVKg9zbeaiEPdCMVzyrVtpOntiIjbqicc7vcmzBxlm5jZ6CiNsIqx0uIz1hFcIZxz+CCz1Qi/Uhl2xG2PG5TPkFKUTpS4iI6gCGdyT0AceZ03ZEqsrNx2b11ghwhH3Ie3UDJxy0rhgWUIpWvKs8NJeDdo9+9D5qdBx4gb+t5YqnPTsGxG0tUNyGszDjDwtzNt4DnEx7WaVjynZottEm8nC9lQtzAE4V2nIUHZnwm3CAtIBqKKGlWmrXCuuKJKscGzWFMAbJRutEBVeXm4C2OrVHisvOVgJajuTLhaHC2Y++KEs4g27zYMlp3Cmps3Vam4E2232Y74xHuVeTqANuDG63tLB4srpylWblGy+rDV74qGl1sxZemXdQgEeZVhrWT1dabmJg9tcZ8sfJTfLQDSXo7S0bc4rkYzzj7l5FqiWf3ohiCoRGnyso0WuO9z9yxDWFiVstmLJXFaqeNqxEafIyxF688zLV1R4LI0c4DMbR3kb3xVOqVByoVR593tlbCHki2uwxPw6Q2b5ELDOso+UEDq1YjUKxNTP8AOHGI+5QvTsZKmuS7fO/9ZHyVWjyj8y4J7PRDjFaxoKpUuiYbblhL18wWcfZhBB6QcSeHaFaMNUYp1Qkp+bnCPo5QHlhdugMFYlab6smdsInHjElnKQuqVA56evcK4YaR9mCtOT5yNNJlv61/r8MEQ+bHRmdsTwul3DwQ36O3NfS27xgtwZD5MojrLkhxikXTKvPWttkYgNowHgMFqqgxJu08TlhEQt4CszLzrlNnBJstHWq1bsknpSYlJUg5c+ZNoFPl3RKLr2vqBEqtNhMyt7fXxgsvLvRYmBNskYtVqVBqYKI6lYk51t2RJnZjAg/zlXqjsXbTFU5MTFy5QKs0URc06SgrROm/K5EVxQSmpUycz7KmlWIj2UAlsI3XK48zF1sYjzK4UlES0ir0nK2uWkOlFhMmzFshjbqgtAMvtWxeEdXWpGZL1nLxRimytouAQ+5Aaoc1EZMQL7KkJ05KaFxstMeKjp7P0fIepWpxqDsqMe5ej4b6y53rtDcUCbhMsjEbSWkbHTykua4QmItPbMi7W5dKl8yEY6rbV3u50OHO7SKmb2naJIRMe0pGyjwUOiTfxHUpRjmGcRPNMHO7IeVTiT2ZZFuXNrSrG+lgLsEzke4wWyWb9IjO3wXVB7hz+5ed0cDwM1tKkMOUb4KT0lOh0x5vtXx3+JTejZra14Q7MN8fhBAceTW1rT2q4r4q0SzrObZc1qNSM9FovcszUJoGrScK1OkpuLjed2lGNk9U4vjaWnuQmcJsmS06o8VRKoA0ObpWiqc5Vdo3p5OpBVmig1aV2qJbgWgpzvqx8UMorJ7VyZmB06bro+5aKTO5638VQqr6kwpO/LOC5WJFccGtnGPnBXJVrpNNelnN+0aiP3QWL9B07F+kzkoRfVnfCHlFbSR9VNEPgO2MPfvR0cNpbHybix6WLSJlvh7+Kq1Bl+RxUy844NsCsy+OaIY8ZmKX6TnrtMqeRtx+0m4+lGGZ6XqgkV0RhHLq7kDsVMQbnJebHTkcM/cS6RTfW02Xj/ONWx/F3rF4gEJ3DrbzWooy8Y/jCtJg6oQmcNyZdoMhj8dKHTcYUO6k282X7UWeag7syLqWXwdPQFyaY8BmP3RWmJ5u2wliUzYxG7VpVepVOUpMm5NVB4WpcOJkrDZQtyWT9J1NhVcH1CXJ4WbB2kDLdDMd+SMZmc9MUoTllGo81N5laJ2xyJbzD1Tm6pSWZudlSkn3OZouIrj9B9KlDptBk5NujunOMDlGDQ7ijDrz810TBGKpjE0q9NTMi7JZFaIH3d6nZeri/ppZcaxo8bv4Ub4fqXSPQBPHM4TmpQuWXfjlH7SyP/CDZj8pU2attEwiGfnnmiH/AAcppxv5YlHBIQMQOES4bk7OnaHjARuu1Q0xXI/Ty19HpsyOkoFbn74rqzjoEOY80Fy/05ltcMtnaV7Zw+5dEL2DKq23RWRIb3bYZxJFHJ4Np6wvyVyfD1TdGntw5R3b1pG511/l5fZVapy2BTrTd3q7vMlRcqsCc1CKFssTj42tskX2lINKmSuFx5pnLfqJNYZtKxOVJ8hGI8oda53jp2Ey8J9y3zMo0I2PzQkEeMRWVxpTJASE2JohH2hTgVcAGEpOOOtc5gtx0t1z7SD+jjDQXFOuPC6xbGELV0IaS0LekU2bhk/XuiWkiSKRffZtErPNbRuRYaG1sdSkGny5Fq5ubJNmaMbJ0dwRtJwnSjxuRKn0KDgltRPm3LTCxBtvlHdwiKdfEdLY8VOytQluhNiQkPLDirDkgw3bcI7uMbUUutG0uZQuZuDmVt3cp2VqqiyDolBsbe6KsNsRHm1Kv0ptl4YXcVI9N28o/FBYINQlyjBNvB0fq9PKhrk6Yt7QrR8lH8ptiJC3zdyMU8VH0mmuS+xIRuyggdAogSLjcbdXWtBPTDbgjF/SNyrtzQOlm1y8II1mfSJP7N6VC7Q2BnCHnGGSzeCi+mS7RdWbxe+Kj9IFbbcqTzQ6ib9VD4b0sMnCWotQqbpWZBEW7u15KtU7DzlTApyaPaaYbofBBWZo3HJyd2giLI77u5YlmpzDt20K3MolFWqo84NDbAed4s4x8oLEtVNVuBS7bDRdm3NV5qqt09mVuLWZZxgsbSzccmGw1FmW/wBymxIe3nrxIrAGwYe5BqBrEKhPCN1oXcUFqFfMqpMC0VzV1sI+7co6AJty8w/bdpsH4oLsTOcsEbiMuArQeem3Rpb0ztiAo6YQHtIHJzbpOCN2oyRioS+zlW5bVu3p1JwnUDHpRM2hDeMC4kmsiniibccGXkxL1TO/L2utR4aehLTXSXBuBsboQ8UUY+adRqE16wRZGJb4ktI5gCXalRBuaIe+PiVaS3MOY1J5ybqDjzmo3CzVyYjFqnjLlzHviujYcw7S6fNFtx6Q71RPfAUQrFNpzZXtybRF1RW/TNnLaHh+oT1z7UqWwDrt5vcnPYdqkzOZEzstVt58F0iRrfRi2JCIB1QFV6xNwmy9UVyaQnIL8yGBptrc9c7H6z3obL4flKbNbZ/6QUPFwVxypuyjlhFpgpG5hqoS5ataawzlacZo023n0cduhc8y5KF6rSPcKDzxHKPXNkSKM1Ppsj6znBMtSSNXhMlsZkvKEUNr0vBrW0XBB549nMZjpyVop2M3J5Oc0FmytUlIrUWvUvlcEdyG1oobYoih7mYvKaYvdZU7GqamzxtskzdcKHz2ZOKaUYiJcysPSu0JDVDK5kzYSqlLxFxFJeViKvDT4ODcsUDtsbRvIk6XktSMDJRbt0q4MjqG0eKASMltBy7UE7oVo5LSSclAXLS61MVPhtChaiAWXlNoznbqgpBkI6Y2o5TZSGqBD7kSGQhsdK2rZB2ZLUMSFXBkoiRWok3LgIq0Uvpz7KxijTpW3aCrDkvFuXIeZWpFmG096sTUvaNo80VdQLooRZmm3OXUuoSupkdXZXP5FoxLIhL3reU4vorNw6reK9OdoZ2tCJ3K1d4htTWsu0pG4qWkIw7KnHgvBKCkhllu4KRoENxMzt8O1Ru27OXPL7kVUTwQdbcbLlMYwj8V53R84+jIba5PD2gYjb7+Cw+JGjYnHpmdKw7rRb6y81uMHTQUT0hCE2PqtubRQ98Y5IL6Vwg7XJiL7ZNHA4i2Y+GCJlzsZebqk1m0zoDxIo3TYsD9JmmAHuuQWaadY+rcOyPG0kNcacc8REg00wVMEcnZra+QqqVQkG9LTJFl4kNkaRMOl67QH6UUGgBbqcIiWp4U3qnC64WdKNU8T2LcwI2tGhrdCt+sc4IwyWykdjdpgs5bl1j0GVKDWIHpYitF9qOXvFdKrE6ElVntVoODA/jDcuB4GnzkcSSLzRat8PvXQqxXQrM0INFrAohGCLC/TrNNjWKPON/h2ob/ALKC4odl6lhuXcfIr2xgI29/FV/SRNmMjJy039bK52x8i4IPRZ/ayZNuahtjlAvcimootTB2hssuFqAv0RTsEVPZS8xLarQKMfujmsXh2biNwFywGO73KSh1CLFWcES0RzGMEHYMBVoJnEU0HjGEYQ84wXTpd+5v1jdpdy+efR9MdExJeXKZLuXygAiXht3LEjQu6lTq0qxUJNyWmRvac0lDxIb8pwuHs6VVmqqDY3uPZDDfH4Kq1lM2hYpuHaPSxulKfKhl7MI/rRJyaBsRtth9kYQ/UuH1b0q1GZrjbNPZEKXF3ZbQx3knUfFFTdxpUJCdmL2AHNqFvLBZw3lc/wCEC+DtJppiVxA/vW8wRPMDhmmm220GbEM4iMIRXIfTA9F+ky5e3x+COYOm3XMLyNrhCMAyVVrtZE21q6g9V4CJDdb2c1gfSZNQncPuNiV2RZJzjttu0e0x8KB4uKDlLtYLtQ5l0msVhFbTaYWMCS9P+R2zmWyModRLbS4G4P0RlpkI9dqzeFJSDVJZjzHbvW4pYNiyMVydlEaa4VpFMF7hThpDThZkJFl1kSKOTTTZW8oqq9VWmyy02rBVeprbDNw2CsHj6wZcu0UeC2k9V4O2g1yrmuOp4HJptoSu+z3oOoejBoG8Hytw2ldH8Zah50BFZnCRHLYdkWC0lsoFH4op0jxLGiF4abvgqb0+w04Vo3nDrVWYe/Gz4RQ2addbK1hm7PjFBpG5sCbzHrUbk14dSFyZxFv1nWrBOwHmt38LU1TstbY7r/0KNx1wrri0qm89Afww29arvVWUa0XCSrU2XhaC7MvgmzQxFu4SsLvJAXK+20RWkJfaQeoYogNwlqzVM2aR6ag6zpG84FxUebYiT22GB29rsrnsxivZ8hW9mEEpNqu4iuGny7uyjxdPdBGLFexRB17IXLrNKbL4gfbprwS31tt2fhUkj6LqpMzA9LeGXahxO7OK039z1uWl9jKTF49cT7SzWRxOcBxyaKLpEWZbzJaiaN/5FblxG1iHLD9q6JTfR7IMPbeec6ScOAcAFWJrB9Ocevccds8AluVaSOIycg7NzljDZF3xHgMEUrEgbhC1LNk6UN0ICK7VT6LJSLJNSUu0IR495KMpRiUcGLbIgXeIqq/F+25cvoGEKhLM9KfZudMdLfh96uS+CJuoTAxnbWWLsyh1rpwjAhzHmQ94oC9zKtKp5ZmYwnLtt7Fh4mmIDbkKtUSgU+nt5tM3vx4mW+KPTUWrUHGfbYcLUmY9HJTUlLtFfsRu7yFWpV5txvIiQ2oVAHGy1XIP8oHKb+ym5gWqE1s3Lh6k35aByVyItfKs+VThMuFdpJCak9s7iErVM2NRacecFzatl+Sqrlb9YIOlcKEyNVi42TLnwQuqPes0qdlaj1WMHNbSDs1JyWcG4rtSqys7Eh2TnwVGeO5z2VmxqPVZ4HW7xK4YigsjOuS0xm2XHinMnEpchJUxajtMlOxgSqj20HMVRkzMXPerWxcJnUpJeVhdq0l1Js1RnAiRZp0q054UW6JEtNtysS0pHgsaz5SjguZ26VMMr1LSDIac01ynhxWAKzJHcrkvJGLmrVmjTMoA26UQZkIC4JWoAIyMS5W8lalZS5stKOMyXrPf1Kw3KAI5LQBckIiyMRFTS7N2z9XwRxyVtZyTZNmG0ER1IKLkvDaDaNvmrDcvq5UYclIFvItPenS8qBb2y4LWALYRF4rdOaJNy8RbyUzkpAXMyVxlqOzz5clWOU9B7bNz1pCrhM6bdmphZj0gY95K85L2lzcRTAFyrUdoRW2jBXHmok2Om5TSsva8ULrkQGXMhytFMKBZUfWCNvvWulQ9S34UNl5XxCIo421ARHyXWsswa3s1YbGHZSEIcREVI2EC5htRhwipIBlDJIQgPKnZKVj6Ynpi4tfOPpUko03Gk081p2hQeH4K1XJD5zYfbnWBvd2WrvzH9603p3pVwyNRbHvaL9ax/o4qsZZxyTc5HtI+zFVVMuXzDNpEyXNBUZWUMprTqyW89I1CmaTVhN9sRGY1wiPBZ+mtRIruBLUJJWXjpuG1XBlfEr0qzBwbrlablYkKpILMSsGx5rkJcPZvEFt2elaZ5kBuEuVZeeD6dp5bVKqilMGJPM6rdUN4rfSMpGSqUm4WranC5c/p+nYkPNct9NPH9BMuwYKHUvTbT4CzKvk3dfu0+S5XT3ojIzEB1EA/tyXbPTSO1w3KuN+OH6Vw2njHo8xbzW/tQWKI9HpDw8uWaUq9s60Qjy3KrR7+nPbTmjnmpJFo/ljV4kHQKKYN1JuLZcN8V0D5Qccl8ruyua0/IXGzt1b4R+EV0CRZfdZGLbemArpVzukbmHf5xNnBB+XcZcctJwbc/epm6U4+QiIl71cHDrhEJbMiGCZRq4XNU+ssENNalSdBh+LjTg9pbDCFEn5GceqtWK6af7A77V056nyVNlek1J4ZRjlzIlNTfkeoNkdNmmpmzjZvWaxlczMw5P6VBdcw/tXBtGB/sRT0fSEzN4bk4jyb1c9OcWG8Liy2Os3f2Ip6JsRUpyi0+jsuXVGAxiQW/em2smu1VxvDrp23cvWqOIKQEtIjtOWJZZl3rp1kRZz7+pZHHTTXyeMS6ihu80mxWoKyINNi2JaoD2eCvMzEw23kL2nuFCxnWG7SFwFYKuyzY3DqKHhULXiB99zO0iL2kikDK65wRQVzFer1Y/FC5zEbpcpWq0D1S2csy9ESuIBXOZGSdq+IGWua84ZxLswgr1QxFHZkHMRq5hZ0JQSnHPrY8EHWMwlmWxErrBthFV3ptvxLCvV2JcpFuUPTZ2ZK1iXdPPwimrcts5VW29Fw/wAKrvV9pu6Fw2rOs0DEE79XIuj5kiUv6O6y/qfeaa74XIxC9iK24Wy0xVGYxOfDaW5LWSfozlBH6bOOn9lHJHAtClP+ak6XtkjdXJXK0+/9WLpl7OcU0ZStzxfRpN8s+shjBd0l6ZISn8mk2A/FVzl5d32Ubq4jL4DxJN6nbWR9okal/RablsZ6ofAF1AiSFDVi6X6OKHIuCbjPSjhwv4LWNyoMNiDLYAMOEAHKCkIe0lvW5ajs8SjcCFqjmHoD2uCqvVALea5Mh10LrVDMDARLShr1VaFzJV5yrw2JRElWyF6XdhcWr4KjUpiDbw9pZ+Yq8Q37S0kLnqvt3ua7zTYaxupNiNpFagtQqcNt6vVks7OTRi3m2XwQ9upRF61wtMeKnIOTFaiN20JVymoPtkYkg9Wdhbn2ULkZ4xIgItEUyL01UHWHtPLBTOToPyufatQWqO3FcKrybx223LNm6nOTRtuXCXaUk1NQfZz7SozAxIiTmR9Xb2lClUXbXM06azcHNSbGG0JWuixcFAJlxMSVhxq7sq43KGLmWpXG5KKwDWWo6dKmGV1XWotLyke0PBWm5SBdnh1IKLcvc34lMzJQu5UYlZKH2VaGUiJDbyoBrNP1DpVhmStIrkWblfDzKYZe0syWge3JaeW7ySKQhs/aRhlrSWlSFL6S/QsAduVhp03IoywHEtIwUdkLrRRJlqBN229laKLMu044Pkpujttly3KaVZjtOVWnpe5BRcZ08ulV22gbeHTb5I0MvEhu7MFmcaT7lNkWwkhvqU2fR5UB43Fuz+CutduIRM45B56UDF+JHpZy4qNTM4O2lltXo9WcPCrkl6PsPG4QlJul/wDzF+9arD+HwoFBl5FogIoDm8f845Hmirki1dNWq5vNeKzwytI7jli3PR3h8bvoZf8AjF+9SS/o4w+43mUmX/jOfxLcPS9pOKaVl49HT6lvZpX0wrno2w9cMBkXd/8A3zn71cc9F2GxIfoJbx/nnP4lsiahtG4lpVxwNQ+FPqWz5NK+nP5f0YYbJ4oOSbtsP++c/iVpv0V4XIc+gu/nDn8S20uGolaZGNpQT6lvatK+nK5qkMejuuSNVpokFDmihKzzZFE4NRjHQ5vz/t9pdU13abSDvFV6pSperUmakJ1u9iYCIF8euHnBZX0aVOZabnMMVhy6pUctkJl+FY/BnD4bvyV0ztGe0/jOOm2EY3ablIOZFpuFSN59mxSZLm6GtjHtKbJNFSWoCySemLi1m/SFSIVnCc9Lj9aA7VuPhjDfH9C+aZF45aevusz4e+C+uHAg4JAXLEbY/FfLuPKUdJxNPMW2jA72/dFBtsXSUMT4DZndpdMSm6PflkuOyJRYmhBzUMCXVPRxUG52XmJB3SLo2RuXMcQSrlLrk1Ku8zZxyj5dStya6mygEJEPNHermwi0N3MMEPw5MbWXGN2pGmyi6VluruVJZuc7UR5Vl5gIlNPH3Ct5VJJ8rY7O0Fj6o1BrbF36VLpU2njErREblspp6JMysPbBZOikYzjIN8x6PvXQMQU+MpLycdncUXQhkoWKel0oN4Rbj3EEVxnD8vCZZcLsx1fpXZvS61B3B7YXW5jDeuT0Bl1qgzBsDcQBx+KKV6TKwKsPCOoYFFWpeVvrzmzHTA+CdgjN+acccbK+OcS96IYcCLtanHbbsijyrAYpMvtJxkbbcyju+K7NIyEeisw2fAYb1zemyUBqkrdpLdGPx3rrjP8AJRiXUK1KvKysR2kXBt7rVzv0lYlm5HEVJpUpOFJS7hQcfd8u5dMF2BDqK37SwfpGouGa7sY1aoNSz7fBwXN+XcsGBrTp+kLHQyDcw6VDlBtIx4FHrirHomlIU/Glal6e4Z05rRA+rNGKVizA2EJEpGQIni7RhvifxQ1v0r0xh5uUw7Qxa2zvEt12fWp/cyr/AFB3p3dP5LkwIbb3f2IH6DJfaYocdHmbYNWPTfWHJ16myTgiFgbSNvfFEv8Ag8M2uVacLlgMAhH3pPk6diendhLjEhuK3dBYnGXT6rTSCUbIpiO4WxWscnpQXChcNwcfZTcHTfTatNG2ICLG6FvmrS5jS/R7iabti76kY8byWqp3otf/AOe1C3vgGa6tzdpNtVp1YeV9GtHaH1pOun3ofWvRmw//ACBwWh7l0lJFauPSfojdKYzm5xoQ+zGMVqpX0dUpgR2rjruXUtuvLUNQWTwxRpT6qRaLzJFGZeXa0tS7QfZFTWpEMEHqZs/aTtyV0FAbklvTSOCjJ2CCQk1V3JiAjzKq5PgP71YvFlcoydgI8qEzFQAeUkNcqXWRJqwanKg203cSDzFVhxEtKG1Sd2jdo6iWbmpsxbLVbkjNhipVeIuD6y1DXK1BvcRXZoDNTsHXBiRcFTnnYbNUkWKfi65mLipzk8bYkFyz7M7FpzmU1SehbmJaYigJMzsHG9XMg9QmotuZtqnKvRFxRzx3Fp61IKNzu3lfbgg8w7Hac3BSS5HbyqFwIk5pFTsLDkxtGdSHt/WZogy1pttThlI3XW2isWqzAG42PZUMvLndpRjounUVykZktVraAaUoZXdkVIzKwEUaZkjK4S0qaXkQ+0gAjKXdlEm5S220dPXBFm5SIjbarTMrpG7mQBeies5Vabko3cqMdEhaKk6OdyxoW3IWkpm5cLsi5kSGX1DcJJCzaQ+FaxCzL2qbY3FlaiDLECuSENm9zXIIRZjapBa0+IoK8LUfEk2FvxQV2WNJXCrGxuH3KwyECEuYSVrZXNl5IAZMwu0jq9pEG2TFvK0eVJ5iNyvC19XqVijKtRF7IutTEJkRQEeCtS7UekDcrAtc32kFMQgMm4bhWjAd8VgcKS8cTYkmMRO/yCXKMtTwLtQhuNz4ox6QJ2YmRlcK0krZ2pl64x/BS8Oco+/gtRTaaxT5GVk5RuxhgIAMPKCuv21/co/KUz0vpbuG0UpGXgMxp1Ig4PqxuFKTHUoWpzDXrnNKklQPo/KrEwFxOabs1DRJ6XqErODLEX0V85Zy4crXB4/rRhwtQIhUzgXODpVOj1BiqM9JlCImoOuNahy3iURL9MFJI1eUqFHbqssRdDMIuwiQ5RyHPPd8FWsi0yGotKkFqFvMoaTOt1Cmy87LXRYmGgebuHKNpQzhmrghp0ipaQjER0rn/pIkJmmzUni6mt3TVN3TbY/h5aPND8XiuhEJ9lRk1Bxtxp4QNoxiJQLfAoR71dJ1RMbIaXNtVCRl5yScF2XfCDjZj3R3q8K5vgQzwpiicwfNkXQ3M5qkuF2m47zb94/xLpQqrxiW1nMEIqUeC8FSZKFiaYnEmrkEuU+nGgbWTZrDA6m/VP8Au6o/BdWVOqSTVSp8xJvjc08EQj8UHy3hyfjTao3G60TKGcVN6V5cPlhmea5Xghmm4qo7tGq0xIvjaTZRyj4odUVHUHTrOHRZL+VS5QHPrtVVTNezsKOg2y2X3rSOZseu7MOK5+zPRki6NsyEYddq0TeJ7WRFuTJ3IbY3cFqBSpVA7bHC0x4LH1p6DjjcBG3rjBXpyqzj+smWmg4QuQOadi68RuFcXeoVUcwc1t8QSIe3CP3Lq2KBB2rUeW7MX84w9y5j6PP8PNvFytjFbqenQnsaU8LrRlwvK3vjFFpvTO6DVBsEtJrnbIxawLUHm9JWQhCIrQem2rwJmTlhLWfUsvXHeiYFZZutJ8obkUsYCDZUeemnew1Hf71c9HhR6PPTJdfX5Rig8xNwpOAXIN/WzRQCCIYULo2H2WyLU+d0Y+UN6DoFNNuZqzcWi0+rGHwhvXRimIsFaWoIjbl5rl+BB289n2YEcfvjuXRCHVmXNFEsf6Z6m5JYNImHCZdddg1CIborgtDkH8QVpmVcmCET3k4ZR0whxiukenupXOU+QErtmMXC9+e5c1wpV5akVTpU2yT2QxEQHz71Eqr4a4prAVGcJhqTmqtMNllEy4FGCF0AmK76QpOMtJjJS8Cvg0PZgKrzGNbXnDp9Lk5cTz7OfH3wRb0WR2VQqlcmfwDRlCPVnFBR9J1QCdxZMRa5GdEF1b0PU2Elg0XHByKYOJx93UuFjtKzXOXXMP8A6IxX1BIy4U+kyss0P1AQCHvVV8k+GdmJWccnno8rEHd3tQyW8wJKQakXpi3U6fEfJZ16XN2aFkS0mMA884x3roUnLhJSbMuzytjktTVMkm3pXoHJZqO+1NJ1BJckRKuTqjKYgPaWi1elzcyHjNQIslC9O3FkKw2EtsA6RULk3aoRabab2k65bn1KuVTkBK3Z/G1aJnJ6HKSozUxG3NsrhSeCXnGyjJOWnDsLNvTbktME24NuWmMFtUzZemp6I+1mhr0/pIrlTqkxEbSHligMxNR8StIw5UIkWd1qouVO0siK5C3HeyJXKi4RrQaeqUHByutVfbQcuEuZC7okPMmtnqyuuXORTqDtrhQ7lV6REmSHuVqoAZahHihtpjpWivd6xWnCiTI/oUNmrUKuDLwJnl1KVqbJARWlzQ61I40BFpVhmVjcOm3vVzo9pDARuWCizKgO/tdysDJA4RFqV6Xl/WahV5ljmhagGtyoW6epSFKAQ5ok2zzXDkrAtXN29lALGVgKmZlIi5ciDcvC7l0qZsPyUFVuXhxIVYZlYXFarTYQ1DarDAQHfagp7GIiOq1TNsaVMWScIhb4SQR2Bd7SmEYpCENopiDxLdRG21tNJdSa41s3FYlxuScCF2rqVahzOQt6khyIsyVhkIbEktlAi5UDiagVsCLspwtBptUhNQuHxWqRkbUELIWiVviVzWLJWqNnIboe0rG4RLtIKpBG27SrVsbW9IqrMFp0q0ObezVCRkfWDdpJV6tOtU2nzE5OuWS7ARNyPlBWmyAnNXMsDi4o4pxVL4YYL+90rlNVMx7obwa+P9uVbSuZTM4hc9GlPfmxnsUVRvKfqf1IF+Cl4cgw9/FbK2OlSMjBuVsb0hDKEID2VGJRuG7lS05nLKxqtPfVtpSvNck4WkbUFqE3XGJoRo9Nk5liI7zfmotRuzjuygMVmqtgOm1LFNblSnZZyiMsG+6AgbLsTGAOkG+MD9lSUWj4tpbc9sJyhEM3NHNFey9HeWWeWqG7crHo02jmEZWLwgJxfmboCWcBj0hzPetdv2fsq5nWZjCIjaIlh6BRcW0iTKWYmqEQxdcezNl6MczKJR4FDvSpFAxbTcPt0dmcoRMA0beZMvRPIs+u6Hf3LdCMfCncxadKzeVaQx9FpuMaXSZOQamsPk1KsAyMTl3oxyGEB3xgcEcwZU5is4Zk5+dFoJh2/aQazgGYkQ7s4xj1IwIrnPo6m8RjhumtMUuQOQvc9aU7GB27Uro2WR4e9b+UTLPxmHRrY9lOyUYqQRj+KoWyPpKoExV6O3O0nTW6YfSpMx4lEd5B+NCCNYMr8vibDsnU5bTtBycb8DkNxD8IowIrnLP/ABG9IxM8mH8RnmPgYm+7yu/tyq6/dGET9s5dOFJIVKPBQ6LaSSS5DxJe5pu9Bzv0v4YjVqeNQlG7pqXH1kB4k2uDvCbRZtFYfevrzm3FqGPGC4n6TsDHIzDlSprZFJub3AH8HH9yDlL0264P0nWfeKj6aH84ZeStPNeyodiF3Kt2NYUZgzdLVy9UFGQ27lccDVmpKVTzqE82w31lmUfDBYDWFx6NL7TtufqVyiT21rk5OkXDRCKdXGQpdLzb546GoISI/J9P9ZpKA5x98VYE44mzq2KpcLrhbFV8STfSZ6n01vULI5lDzSpLJ3TVTmR03ZwuSpci4PSqxNjb1wgX6FCkeKHovvU+ntcjO8oe9FHHosC223ytjZD3x4qjTZI/XVWb0kZaYF+iCkH1s4MC5G/84ooOyejKXtp5TJDx0fctdOTDbem7gOcfZXN6XiVul0tthshhYgeLMbuNUuYBkbTfzCEffxRDD4+q8aviScmLrggWzH4bk6RplIp8u29iF58n3BzGUY45R4ZxWXviJCXahvR75xT8yN4y7BOthbF23OOUFC17EkrRBpMrMU2Vflphw7dk6WcSh3o9Wjbw76PZeltkPT58oPPd4j3LH0sXJ2aKoVJwiaZ35l390FHPTUxW6ltHLiz0w9mEEG09DVChPVwqhM2jKyY5wu7Rdy68VTcdmMx2TQN/hCLmj7lymk1WNLpoyEhpG3fEeJR+C3GDsJ1Gtk3N1Qil5CHYLdFxdK/ameW8wZKRfIqg65tQu9VEu1HvWsI7e0q7ItS0u2ywIg02NowHuUMw9asFonfxlGT0B5kHen7VReqURLSSvU2aJyYh4lXcm4dlZ0p27fcoSqGotSap2HnJu3tKm9OoK5Pw8SquTceyqZs0QzUBZI+0rFFd27xGXK2N3xisz0iJSJREuBftRTC70HRmmrtcRhl+mCiWJnpt2oTwg1cRGVjYLQjhKLkv62cte8hzgP6VkqHOhI1eXef0g2dpez1RRb0rYlmZOmyNGw28Ma9XD6PKuAX1Tfbezhwth1/HqTmZiIVxiZkFqPSaNUSA9zrfh4FBNxQQOysrPtD9YMBj8YZwWSr+EIlPkDeMMSTmzGARednYxzjDjb5L2pYFdlqPLxPFGIiI8vVFNRsHdnuhkumtfbntPpaJ6JyJDbqDgg7msuUlC3gt3orh/OKuj5dIVUcIO9qvVv8AOE1r7Np9CRDaKa8N3ZVMcGmX/T1bt/xj/ckWDTEtNerf5x/uW4r7Np9LWyjbqFVyai2XKm/Mt0v+nq3+cIbWsOT9Pl3JmRq1TmJhjXBt96Jwcy3xhks1iezafQg8xcWZKi8yAlpHUjVFnWKpTWZxgdLg74eGPXBKelz2l1oqJjp0BRYhq1K82EdnyipG2NRQt1Wq1Ks3Mj2SRKmI26SVoZe62KmKVgJc1ytNtQJsUFNuX1XcyvNs+ypGwgJD2clMOSnUR2c2lOFkFM4PWkIw0qtRG2xG73KZvm1ak5sIXZpw5XJqEI9dqmZGBJEPhUjI+1qtW6iqRQutUzYwFu5NII9pWhD6PqTAhshdcpHA1Db4UhCN3sqwQah+ytEMuFxZp1sNoV1yjnp2WpNPmp2bK1hgImUf2Q96+eapi+uT1QmJkapPy4unGMGmpggAIdUIQhHqXX4vim+UXvFH0o2MCbJNEdS+ZRxPXR5a1U/zpz+JL5y13+mqp+dOfxLp/Wn2n+xHp9SODaLcbUmRuLUvlv50V/8Apyp/nTn8SXznr39OVT87c/iT+tPs/sR6fUjYwEi+0pi1NlavlX5z17+nKp+dufxJ3zqxB/TlW/PXP4lv9afZ/Yj0+oiztG3qVostMe9fKPzor/8ATlT/ADpz+JfQHo0xLDE2HWTfK6fl8mZiHnDgX40FF/hmkZVT5YtwMYmq3yDQahU9ntSlwuEB7UY7hz8s470N9HFH6BQRmplwXqjUi6ZNP8bolvhDPuhCK0kxLtTcu5LTLYmw6MQcAuBQjDKMFi8ATDlEqk9hGoOERSucxT3C/CsFHh7xj/bSpr+MtnzDfWw2ZJohqSEY7MiEtPcnNjp1EuakhBG0UHqXzg6UPyJ8k7CzV0zaX3Zx4W7sskWIbrfCg9UlK6c0MaNPScuxZqB+XJyN2cd+cCgqqWU/Rlf8z5Xa27XbzN1nDPpDmeWart4lnJSi16ZdHpcwzVDkpNosoQKMSEQHd1ZkpvRkLg4PlRdK49vM3REcoFHbuZxVNvDs7O0WvMtj0ebjWDn5Nw+GYkBBGOXVG3JVxmcs5xGFiaksU0unuVJuuBUJhgdq7JFLtgy5CG8gAoQvGPdGMVHjKanH8K/OSjVqclGoyrbrbANtRArow3xzGJZ5F3qSeq1fqUi5TZbDs5JVF8ItuTD5N9GYz3ROBwKMTy6oQgrmJqE416O3qPS2ymDZl22WgHiUBiMP2J3GT3gcoUlMSMu4E3UpqolEs4G+LcIjDuhYMFj/AEbfOb5u03o3yP8AJ17md+12tu1K7hpz7l0AQhb4Vz/0cSmIiw3TXGKlTgkL3I7IpQouW7UroXXw4+5TXxLZ8w6NbHiScIpttvMpBULK1B8bYdaxPhuaprpWGY3su/zTo7xL+3UjgrE+lKsTLcnK4doxf35rR7Bq38E123I+6H9tK2mcxhk4xOVz0WYifxJhGXmZ0fpkucZV8+MHHBy1DHrzhFbBDcNUeWoFDk6XIjaxKhAIR6yj2ij5xjvRVZMxnLYidcLKW5JJcmlFRkSTihcKIoJiJQvCDrLjbo3tGORAXAoKEnY+FN2vZIkHHcdYAdp7jkzTdcmZRjCBdnyXPXpR1r8GS+nph0NiQv2GEeMCXJ8UUVtuYcmaNMAz/wBwe+HwW6jB03DdTqjljDJCPW4e6AwW+o+HJOhSZGTgkUNTrhdr3ILI4jnZJ7o08IiHeKOTU1ITzLZz840MvDmbElQB/J7lZqhTjo2yrelkC/WqMxQo1aYcgWiVAt8fFFXK9jKXbZ6JSRv7MXPDBAa9V6nM0nZUlxpoYj6yHbJQHTkvJTMx0Novo8vx7iigtaxFIdIbk2tUq39ZHxZLDz03UWhJm42s+b2kNZzFzNy40U309WAniGLbdkuH1QefiirVAp5zpbQisaDhHxRWNl5psbTmS0w4AKIOYvi23spZu0IcFiZluJqXkpRsnH3tAdaws5OhVKpm62QyYcsBQmexFOTem3SqJTU47zOW/ZQr9rQPSsuTl7haeqHBQuTEuI7IXhaa64BviSCjLuu8xEStM0+PMQpqbNVQxkqvNS8iTxS8ndCEf3ruVD9F1DYEXdsTwGN2Y7rl8902Xi0WYrvHo0xG67I9CecuIOW5VWINm6puF6FSyE2KeJGPAz3owU3Ds/cs+U9HVqVV6pQFVqxoJie2e9DZypXD7SBvVK4tRWqjMVDaXLdWbLk1PRIitLJUXp0+FyGzE1d8VXJ6JLUinToiOolXmJ+JW6kJmpg9nzalRKYO64i1dyDRNzd3MWpSE9dpuQGWmP4UWl8i323IwUp5xISaIrhirVPmDp84LlvDSUPFCKHsjEbYiNpQRZsG5kR6jgpaJViVlnJN6qsPCDQBFx6JFlAYQhnGPkuf4Kp87WahMYlflX/pHqZILY6GYR4/jKPFzsxUqpL4XknCAX8nqgYFyswjnAfxl0CTqUxKSrMswLQMMjAG4CPKMIZQhBb+Nf3LPylcp1H2fr5+0ADVYX7UPrE106a9X9UGkYftUj0xMzf1pEfl1JMsAwN7molzdFWYCDcuLXfxVXZauXSrk4800y5MTLgstBqIzKEIDD3xQFvE9LdK6U6ZNhDty8k64H5UByV1rNvEJzAsMvDwpxMXcqq03EFKnprorE1ZNdTD7ZNOfAThCMUYsSazXyxVFr2ULqkv2h5loGw06lRqjXq9KKc3kR+buKOjFpptTLNruB7rH8ZaieCOlUcQUoKvT3JMisd52T8DkOWKWGKqdXoo9JGyoypRl5oC4i5Dr+K6zXaM9or9vCESj0hy4bdKISoRJkVXmBtmveKJS4epH7K56tQk0rAjAhG1Ih1e0pB5R0pgNEFI1ypwjFObCNxJqG2RIeb8pOENIqYWoWkk2OkVWrEdkeZSC1C5TWxH7KkbBA2y7epmQhdpStgJKxLhqtFGqLjVvLzXKxb6ktPwTXBiJZK0yENiUVQrtjd2bVI4PKldBA8bV1vD9Beni+t5GQ8TkeH70rXacMm2rmvpjxJt5oaJKF6pooHMRHtF2R+C5ovZh5x+YcefIjdcKJkZcSjHfGK8X0aU1jDx2nackkkkqSSSSSBJJJI0lp/RxiWOGcSMvuF9Ce9VMQ9mPa/F4rMJLLV2jBW2vL7DZNtwRJsrhjvhEeGSyPpEpUw7Jy9bpI/32pJ7dq3tt9sI++CA+hTFHyhSSo82V01Jj6qJcSa//rw/JXTBIBFeHWaS9cW3hVoFTlq3Q5WoSReqmAzhDwx6xj7o7leET7PKue0U/mhjR6jloo1XKL8lHqae7bfx6vxV0IdRDapmMf6VWdkhFHTcg9WkqvMzgnT64dPYELYt9EbdujnHfmSOWxu1Jw6S5bljWX9GAxHBsqLhbU4PzMCPhdHpDm/Ja7s6StWHpNHxRSZUpOm1CjlKwddNvby7sT1uEe+MDhDtKOiz+Mat07ZzVCDok45KRulXdURy3/Wea2a7TM5ZFtYiMN0JRu8Smz1ablgcOz+MKzIlNNTWH2hg+6zkUq7HeDhDn9Z12ptFq+MaphlustzVCAHGjc2ZSrsY6c92e08lOn7bv+nQhzXO/RtTK25humvtYiJqTvOPROhNx3QdLMb4796vUKYxlVqLI1Bucw+0M2wD8AKUejEboQjl9Z5rSYOpDlCw7J0994XnWb7nAHKBRIiLdCPvT8YmD8pgWUgrxPFQtHOTDEjJvTU24DUuwEXHHC4CIwzjFYP0ZSj9eq1QxtVGyE5z6PTmj4tSox4+8o/21KP0iPO4mxBI4Jp7hC09lNVRwPwbAxzgHvKP+qujSrDUpLsy7DYtMMjAGwHgMIQyhCC38a/uU/lP6SCnpL3JQtYSSSUCFyKpvEppgoigtQmzbEoirEc9UglC1OIXMV9shubcQOtTZlcVyysxNRHtavZW4Ts2E9X4Ot2k9aXsrE1iqwIiEbiQ96oG2Wreg9Qdi4JGPLFa1Rqk3cRRuuQVyb1Fq09ydOPXFkWlA3notuEPZiuTVx6dNtzSSjbqbjfK4hMw7q5lC27qQFpidN/m1EqLmZCnNhdqEkSl5TaWonAP0eJdlSNyUS7K0XQI2q43JaR0rGsy3TY+FWmaf7K0gySsDJculBn2aergyEdKMNytu5WG5eAigGtylo8qNYWdckqkMWytTRZU1Ol49M08yDoT025piJcR3qjMTR/znvTWxiUuNxakHmjtctu0wXWqBTpEStu1Jrj124RQkXo8B5VILvtalomcL8VISgXxVf1hF4lYbGPhtQQzAgPZJC3srsyuRxwDIdJCXehs019q79GSBSJ3LSSrULRWZlQg3Mc12a1kqNwiskXmWIWqGsVBiiUmYqL/ACMDnCHWUeEBh74olLj6vUsfOD868ZDJDqpFIKDkx3Ov9kfxf4kpG08+GTOohgCnzEpJvVSqDfVKmW3eiXEYdkPhBawng/m00u4U22FyTO05bWNYWttG3SNqjtu3lzJCKksWLZGvSTTUw9U8RF0uVZOASMg0MTgRR3QzHtGUfhBWGWsUTY7QSp1KDssE3F8xh3EUCEfuWqENNpLF4uo7AvdPm6bOV433waGXFyMBlm4w3kIw93H9K61tnhzkqhFxwmZDGlPlXZV84AzPyudgOR5YFnqbjHqjCK0FDkp+SlXJaoTXS9mdrD5fWE1lDLae1Dhn1qSh0yFLlSlukPzDEDibUHyvi0O7ILo74whHhmiBFBTNuitSt0qnUBgTJCrWelV5r6u1ZhrMk1a8Kz+Igjh+uM15ofoE3lLTwD2Y9hz+3+stNOCDbg+JTTEk1UqW9KTI3MPhECh711r9rJ5A5o/XXCN2nd7kWldUq3csbhp5+WmJiiTxXTUhoGPja7MVuJMYdHHTaKTXVNbEIRuUzgQHZ3KSyGpOeDSz4VKkYtQUghqK1TCCRBqz7SBohzJNhC32VM2FyQjbuTUNtgQ+5SDlbypxBC0U0RtVahzmm3SpGSiRJrmVyc2UCJNRG5ltFJD6klHda5yqS65sk1EY+zqXAfSliP5drxS8s5dJSebTdvBwu0X7l070pYj+QsPlLyzls/OZtN28QHtF+5cAXp+Gnbz/ACX6JJXaAN1cp8C5ekN/6UF0DHfpFxbI43xBJyddm2ZdifeaabGMMhETKEIQ3dUF1ta22tYRWsYzLmSS2H91DGn9ZJ78qH7leoXpKxi/XKey7iGeNpyZbAoEUNUIlCEYcE2v6/8A3/hrHtgUfwjQpWqFOTlXqA0+kSIwOYcHI3XIlna20HaIsvdDrTfSFC3HuJhHl+U5n/3SQWVmHJSaZmGrNqycHRuGBwzGOcM4RzhFPyrxxlP4y65LUtuXlGHZHB+HKdJPDcy7ieoZPzMPFAYuBln5DkqVYwxTJx9iRqlJHCtVmx+hTjMxF+nTcfDdmVmffAo5dcEPwzUZCvTU49WZGTqlfd2szMTVYnCYZ2QwhGANwCMNcerPdDqWermIGyl5ymUDpUvQJg234SU0UHdk7CG+wo7+MShnxjDiuNa22dZmMAM5LuSk09LPja+ycW3IXQjbEY5R3wTEkl6XERw7V36FWpWoS3OwecQ6jHtDH3wX1NR56XqtNlZ6SG9h8IGMff3r5IXW/QVirYTDlAmy9U9m5KxLsl2h+PFcfmptGXT4razh0zG2H/l/D7ks36qdaLbSjo7og6O8d/nwTsBYihXqC3MPt2TrBRl5tvhEHR3Fu8+K0AlAh5SWBrQ/M3G0vW29NGq5Qlp6HU092HPj1/jLzV5jD0T9vLohGBDmnNmCdZC32khahxXNZbvsqGn0+Xp/SOjN2DMPnMO6oxucLjHf7laFqPh0qQRPw2qRVptNlKbL9Hkmdk1EzcjC6MdRFEijvz64ptPpUnIUsabLM2SQBEIN3Rjujx3xjn1ohbBIRTZWqGnyTVPp8vJyg7KXlwg00G+NojDKEM47+CtWpCnZLGnDyobiqty2G8PzlVnfqpcM4B1mUdwjD3xRQRXNap/x59IbdLHXh/Dxwem/A/NdkPxev8ZbSMzz4hkz/wCjHosoUzI0uYrFZ1Vysn0qYiXEBjyN+VsOpbi1IV6pmdpyqsaxh5bqTkkslgsJJLxQB1QO1sorI1Z2JCtJWHYiJW9ayNSONpaVVSWbqmRjzWrLzgmLlpdXWtFVC0ksu876y1WxTmr3OVC3CiIkJfBGHh9XmPKhLwARW8yDN1YIiWYis/NZ3XCttPMQLc2N3ks7NSsNQ26lzlrPvZ/jKES1Ig8zFu7SqotRJSL1OK7SS0lNGG0WZkxtLJaan9kkBxuXuFXGWFDKu8oosy0jFUZeFvh70iGAirTgRFkooWTvrLUYkHIRzSF2CqvO2qHbatKlQsJ+HmV6jltJwoWoORw2OZK9hiYbcnitVDZNhC21BatK+s0o0OolVnpeDg5kqqxn2RgI2l/mq02ID2bvNNJoBLSpmRh4V0QmbDwirAhHtDqSbCPZUzYx7XMgjJpU5hrUiwtAoZiXhzLQDs2bwxLxLVSI6RQGaatc0o1TTuZG7mgk1Ydi6sHRqGJSg31GaKDEo2PEnC3Z/BXsIUMKBQ2ZS6+Yj6x9z+cdLmis3hQPnNiZ6uO6qdIZy0iBdou25/b/AFV0C1VP2xqV+7k1NLmU2SjIvCoaozVbpci9sZ6pScu/bns3XhCO/wAoxTRxRQP6cpn503+9ZWpTDkpPYrmWG2CmITMk0MXW74DdBsY7t3iRz5Fqt3+Eqd/kyH+0XXSO0bSIfOigf05S/wA6b/emliigf01TPzpv96p/ItV/pOnf5Mh/tE0qLVf6Sp3+TIf7RNa+2ZlcHFFBEv8ADlM/Om/3pFiigf05TPzpv96ojRKoX/SFO/yZD/aKQqJVR/6Sp3+TIf7RNa+25lY+c9AL/pqmfnTf71YlahJVJkjkZxiZACtKLDkDgMfPKMUPojT416ep1Q6HMizLNPCYSkG+aLgxhldHwJUloG8UYhBtsRCyW3COUOU01g2kqgHrhJXKfqbUdUyG20VYpo3DzKteBgfSBIPy043W5AfpEn9aH841Hmh8FrKHMNztLlZlgrmnAhGEVHVggc08Lg3hEd8FncGHGhV56gP/AMjmBjMyMS7u2HwV42hz/GW4EYdpTTAQ2bNqj3Kw9mLbdq5auiMRhwJNILXtJfBK6NydbcV3aVahzYxTbY/aSt/KS+1pTUO/BJCMRFK6JDknbx3JqFbtCU1uz+0oy0pCR3eyq1CimzDrctJuPPkINNjEyMuAwhvjFK+Il7K5r6acROy1PZo7Fw9K9Y8fVbCO4YR848VVabSmbaw5njKuuYir0xOuXC1yMgXZbhw/egySS9byruHv8PU3/GG/9KCL+kX/AOo2Jv8A9pMf+6SEYe/w9Tf8Yb/0oIv6Qmid9JWI2h0kdVfGEfe6Sj/P/iuhjGkqyHpqm5YGWgl/lYIbKAwgOUSHdlwVCstA36W55lhsQAK64AgA5QGEH4whCEIKlVaNOs48eoz89tp+E/0WM0RRjc5tMr8471LR5d+S9J0jLTb3SJhisNtOulnG8hehCJb9++Kmvjz0vtdx3hytTGOcROs0eouNHUZkwNuVcKBQi6UYRhGEEC+bFe/oOqfmjn8K0ePsUYgl8c4jYl65VWmGqlMg223NHARhB0oQhCEC3QggHzuxJ/WCsfnjv8SU21hNsZlH82K9/QdU/NHP4UvmxXv6Dqn5o5/CpPndiT+sFY/PHf4kvndiT+sFY/PHf4lf3M4R/Nivf0HVPzRz+FV56i1Sns7aeps5LNXW3vskEM+7OMIK587sSf1grH547/EtLL1ao1b0XYmKqT85Oxbn5LZxmHictzg7nlnGOXBTNrV8msWYFPlZh2UmmZmWcJp9k4G2Y8RjCOcIpiS6MfV+BMRt4mw7K1BshF2I2PNj2HIc0P2wRLEFKYrtHmqbN2kw+FkfZjxgUPOEd6+f/QpiJ2kYqbkCEjk6iUGogO+1zsl+yK+kBALri1LwfJGkvXSd4Y30aVeYck5ig1kv770gujuRL8K12Dh74LdNxiI8qw+LsN1F+vSddwq9Jy1UZCLD0Jq7ZvtR4XWwjHOEVCLXpJHlewt/5/8ACkxFucqrM14w3gnEit1qS5YMWvSV2ZjCf/n/AMKdsfSYX/OMJ/8An/wqdP2bfpvByIlMOS5+LPpM7MxhP/z/AOFO2XpO/wC0YR/8/wDhU6ftu/6dAFPXPhZ9J3/aMI/+f/CpBY9KH/aMI/8An/wqdP2bfoW9I2Izw7h0jkh2tWmzhKyLQ74k8W6EcvLirXo+w0GF8Ny8gRXzR+um3eMXXi3lHP8AQgNAwriCcxdL1zGsxTHjkWohJS8htNm2RR1HG+EN+X9tK6EKT9sYgrzOZer1eL0VDoSevLl6gkSXq8UDOVw7SWZnPWXWrSVYbiK3V5LN1AtmJabe5dKpll6tl2htWNnig25p5VqK47ErtKxc8TlxRVJWG3YE3lzKF4Auz5VDLu26VaEYu6RHgsWRBA29Ijd3rP1CUgPKK1TLBjKk4QkIQ059Sq9Fg6Q7Ny3PrLgpZsws5KW8yFlL6uX8ldUcw24UqMwMv0tiHNEN9sfNQ08KBKPWzsmYEenaB2Ipqbues0qbcIYsyrp/ZFaKm0qY07Udln1FxXSJjDD8tT26hRnim5M/qnB4jHujBUaHUOjVAmcVybpyplaTluRteaam4LT6O/0gWm3BI4jnCBbrlevfkroTcvZlwiXaRytYFdnnulUSpdIY529W/JTU05mUkeg4qk+kSAfVu8Yit1ZsD01qWr+zap88LU5/NHuuTZra02odGnqOTzUNzkLd4+cIwR57CFBdZGbknHZbPeNpbxJWsPTE6M83KTpDNnEcoRLtQTVLNlh1iqsuPUkXWSArSad4j5oHUMJVVjUDdxd3i9y6lUppimzwx6KTT/DIuBQ7kYZGnVuktwBwxy5T6wj3RTSLGzgc4zMSzNj7ZAftKPDjsWakPZzXSHKfGZcmJWpM3GBWx+PCMFhapRJmiVYQcEhaPe3Eu5TNJryut9m4kzj9pWhHaChtGPaN582nejEiN2ollSWZnmIjMFb4lYklNWhg28UeXNQyJXEuiRJvlVpkIeFRtjpVhtXqwrPCKjcC7erKiJVqkNmg9lKTOIuZKaa0j4lRlzjttWlVqI6OccLYu6KWmk1kr2O5p/rH8ZdEIYrL1yiQr+HXpO61/wCtYc8Dg8sVJgituVmj/SxsqMoWwm2y4i4O7P4pNdoyV+3hoizt9pQsidurm61MQxFLmXNTn9c+uxX/AI9Tv1tLYYgmnZSTl3GCsM5yWajHdHSTwCUN/fCKyNc+sxX/AI9Tv1srVYsG2nyv+Pyf/wDsNrpPTn7HLYIXWKxJUlyXbnSd2r4mTYNMuOxKA5XRyAY8LhWdZrFZKaGYKcY6KdaOndH6PvtFwhzvu47u5Fqpf89qHd/2Wa/WymntWwtS51ioSLM1KFtWHhzbjbGF0PdHKKucqyeGKg1S/R/Kzr4kYMMROIBlmW+PDOMEWo9bbqU5NSjsjOSUxLg2ZBMW6oFdllaUfCSTTybK8mUPnxVP8Qlv/ceUNNK3F2IR9iW/0SQ+udIcqmKRp+16VGktCzss77s38rcutXqZn87sQ/Ylv9ElWqVyqDc4KdIjaPKlOFc4IqaVzttTXgBao6DTkw84VjQDmUS4DCHFA8CSp1eoTWJZ0ThtvUSTZfg2R6/xlXxsblXrUvh2SK3beunTHsNQjw+K3FNl2mJVllpuxpsYAMB4DCG6CufthNfJ1ulYmYKcxfiKaZkqhOSNIpo7GLsq5EIuvR47+6H9uZFMeVJ2n09uVppX1KfPo8qA8RjHiXwRbDlHYoNFlZBrVsx9Yf8AOFHeRfesrxyeeGf+Zb/9ZsRfnUf3J3zKd7OJsRfnUf3LXbiTroXLcyYhj28EPkX/ACoxF+ex/cmlgt3+tGIvzqP7lsrea1RlzcyZkxDIjgty3/lNiL86/wByd8y3yL/lRiK3/HYrXDlbzJZxuyElWZMQyfzKf5vnRiL89j+5UZfpmEMTSbM9UpyepNR9TB2ccicWnocIZx6i/tyrfby3cyG4iorVdos1IP6dqOYn4Chyl96Z9mPQgQ3aVmfSFhiOIMOuA0P02VzcYj1lHrD8aCkwJWH6hTXJSpDbVpAujzUC4lGHAvxlqBC4dJWqfxk/J8lkMRLIuZerf+l/DEaRWvlCWH6FPFEo28Ad4lD48VgF6q22jLhNdV3D3+Hqb/jDf+lBGcfO7H0l4hciN1lVmI5e54ooNh7/AA9Tf8Yb/wBKCN49CDvpOxA05ynVnhj7ovEo/wA/+N6MquIWJz0ivYiBl2EuVR6ZBosrrYOXZd2adSZ0Kl6UJOfbEgCarAPCBcRgT0I5R+9T1qiSMv6Vn6KwzbTRqwy0G7ox0Rdyyuzz4JkjKtSPpWl5OWGxiXrYNNwuztEX7Yb4+SyMa8ejnK3WaNHEPpexFTRe2EXKjPHtIjdbZF0+GcONuSz+GKJGvTc0wLws7CTfnM4jddsgidvGHHLJaSqVqGH/AEw1+pOMnMC3UJ8NmJW3XxdDj5XLO4UrQ0KdnHyZN4X5J+UyEsrYutkEC+Gaym2vHpvGTcLUSNen5iWGY6PspN+avtvu2QEdvGHHLJLCdEjiGsjTweGXKLLz20iN31bRuZZZw425J+E62NBn5iZKX221k5iVyutti40QXcI8M15g6twoFdGoOMnMCLLzNoll9Yybeee/hdmqnbnBXHBuGaJGuO1BuDws9Ekn52MYjddBoIlbxhxyRqh//SvFX+PyP6nkHwtWhoj9ScJk3ul0+ZkshLK2LoRG74ZoxQ//AKV4q/x+R/U8pvn/AOf/AEqx6SSM4Mw+/ibEUrTWLhEyzec8DcOYl0tbVLqXoCwnaLmIZ1vUebcpd3cDP9n5S7RZaQptNlWKfIsyso2IS7AQbbAezCEMoKxdC7lXz732nL20jWMGkMB1EnC7DhalcAlyqRvK5c3Qmxhdy2qS2ApXQJIR9lAtykEUhFOEVgcKkFNFOyUtJPSSQeikkkgekmEUeylcPXHKPcgsJv4qxMn6SaRMlY5dLmekYnwzQHE2IMWU2Y21zAyR72nGBzhl5qdTZtKwcG7okQgMOstyzM4TbjZGLjRjDwksaWNJPEVshibaywxKwZhrdv8AOCr4iwrWaSLfyaRPNHvZfAtxQXRzmxtUqEm5OFLuE6Iw4xEf3qj8kMVBxxumzQuvw5Wj3G57lqMJ2VKllTsXyPR32/qpy3I/iq8x6NnCnCmabUvpDZQNv/ctYy80w/SGyCpSNhBxAxyiimGKVT8V3fJc10adgO+Wd3XZdy1xPTDbcrJYvlxeOG5mZ43eRK9UsD0ybbGapv0GahvE2iy3wTpmzn81JYhpMw8wxJu9HhpjAhzhmr1PkqNXZEW23Cp9UhueaPteYraYSqs3M1Jyn1Ir5gBtvLg5CCp40pssLzbzAi1PslmMQ7UFVa84RNuMgcvhXEGFvpVGe6QAbyDjB2EfJXqbT6NinaOlJ9Fmu034S61ssPTTjmH7y+tDSQF2Vn6TJOlXBqEkyIZF60OokrHkz4Z2clahha52juEMnEsnZQ+/vgtxI9GrOHemTbLTo22lphmo8YSEZtyXmWuSO4oK9h6nwkJcmh1S7w71M4xCq5zLB0L+9dcGMk4XyW4fDwLVYsaiwIsNti7KzG+MeNsYq1K0JiWcmLh59+Xh84IoLLbsi3Lu6zb+riq2is4MTaGdo2Hw6G5JTY2HEc5V3z7ooHR6Q7LVhyWnS9aGtsxXRmQYfldkRaw5Y+GMEBxI61KEy+Wk7rSPz71y3mcwrWOJOxFSgqlNbecH17G+PtKnhoJZiaE2xHZGOTgdReaLU6bbnpdwCIRdhuj/AG81z1ydfpGIHKeZC7YUXW4jwt7lz3m0LxFZbjEVNbb+kN6XQyzj4hTcVUxjEWD3AIRKal8jacEd+796rzU2c9h149V4Dp9qCE4AxUEy8Um+VphmMYeKK6bJYeh3tETbm44bow81pqUUdQqjipkJLEz2yEYC5qyFXKNmRatKaqyr1pqBXESDyZQFzStNUmbrrlm9jFqY0krrVAsOdquM52qi3yirjY3Cu2qUl0OKbbqUggkQ6kFOYC4UJcC14fJHJjNB5i/pGkhV1TLYUnMpUVk8SD82MUS+IWtNOnMpaowHgMew7/b/AFlrKHl0Nsi5oipqtIS9Sp8xIzbd7D4RAoe/rUV4lXmFgSgQjaWYx3wilmsj6PqhMMdKw3VCun6ZpbMvwrEeQoe7gtcRWpNdZK2YGuF67Ff+PU79bKOY4mptqTkxlpPpAxnpSMY7SAWxg+3bDf3oXOSExVJ7FstIk0L8ZmScHalGA6YNnvjCEY9nuRjbYlcbEXKfQjG6EYXTTvGEc4R+qXT0n2zrcriUXBZLD47AKwdS2vT2+BERW2/jIhVnsQlXKfUJbD4vDLtPtRbKfbhz2b88vZRTpGJrv5DRPzt3/ZKNx7E4/wDM6P8AnTv+yT/gBjK14cC/I/yKO32Gzz6W3lnnmr1Jer5Ygnp+doIS4TDTDOQzrZ22xPMt0PbV4XcT/wDY6P8Anbv+ySJ7E3/Y6P8AnTv+yWpSScf+O1U7P0GW/wDceUdN/wCVmIP/AMct/oknUSUqfy1PT9UGTaJ1hpkQl3CPlicc45jDxptL/wCVmIPsS3+iSwEnhgRatyp1qqsUSjzU/MloaDPLrKPUMPfFWJg4CXNqWLnijivFzchzUmklB2Y7nXuyHw/iV1gmyxgqmvsS71Tqn+EqkW2e/wC7GPKHwgtsLrbUqThOCIAOcYlwGEELc0kUbVm8aTTtSek8NU8rX5zXNOD+CYhx+9bNdk1tgsKAeIK9NYnmRIZeGbFOAuy3DcR/FbRy/TbqUMiy1KSbMsw2INMhAGwHswhuUjkUUcJGlfaWdvvQ+qVOWpMqL02RFeUAbbAb3HCjwERhxihcxipuSEXKpTajIysfw7oiYD3XWFGMPuWYMtNeFpRUN9xaeZU6fX6VPDlJVCVeOPULkM/u4q9dBaG6/DdmpBCPaHikPLndalfES5rhQOcKPZ0pzZueLgmuZGOdqa3n9lBjcWX4fr0rieWEtgeUtUQHtNx3CfwW4ZdB2XF1shIDGBDEeBQj1qGel2J6Velplu9h4IgUPFCO5ZPAUw5TZqcwvUiIn5HXKOF+FYjy/k/25VnR+MtBiaiMV2izVPmS+sH1Z+AocpL5nnpR+RnHpWbbsfZOIFDzgvrIS06RXI/Tbhr6uvSjerc1NwH7hP8AZ+SqpbnCb17cxw9/h6m/4w3/AKUFofSDI1D+6JiJ5iTmi/vlMGJizGMPrSjCPBZBszbcE2yITgWcIjuiMYLS/P7Fv9Za1+eH/ErtW221UVtGMSgmXq9NYhcrTspMxqBTHSoudHjlfdnnbllxV7DUvVJ3H1LnZ2Tmtq/U2nnT2MYQzJ2BFHhuUHz+xb/WWsfnh/xJfP7Fv9Zax+eH/Epxf1BmE3pCpk85j7EptyM0TZVKZKBCyRQKEXS8kA+Sqj/R85/4JfuRn5/Yu/rNWPzw/wCJL5/Yt/rLWPzw/wCJK71jXgnAN8lVH+j5z/wS/cl8lVH+j5z/AMEv3Iz8/sW/1lrH54f8SXz+xb/WWsfnh/xKvv8A0zgG+Sqj/R85/wCCX7lqqbLTEt6LMTwmZdxmJT0jleMYXbnu9Dvn9i3+stY/PD/iVGq4pr1ZlejVWtVGcl7oHspiYIwzhwjlGKma3s3ioSvo30KYThQsP/KE63bPz4wON3EGuwPx4xXJ/RJhOOJsTNxfbup0lk8/dwLwh+NH9C+ntlHxaVy+e/8Ai6/DTs62PZUg5+FNsiJadSktPtLyO53Z1WpwjAt6bkpBHxIsvxUrfCnCKcJLAhzUmSaOSdbajT16qc1UpKW+vmmhKHVdvQWcxhIMFkwLrxfdBNZsnaGo5ki06iIR+0sDMYtn37hlGxa8+MVR/vxUtJE+Q/dBb9OU/UjpvJytU+S+vmgu7hQWcxrLN/yRknfMuCDyuD5l0r5ly3yRyRwrJNfWDtcvEq0rXzLN7WZ+YxVV54bJYdkMeFo71V+Sa/N64k7nx+9dEZkmGBEWmxEYcFNAc4ZpvHiITrPtyNzDlDxE23PUuYKXBwrSly4tEpJemV7C0xcTnyjQz0vNFvthHrh7kWrDUpKVQpmSZtdMsnYB2vNaKqOmNHbea7YagTTwb+Wfl8P0ar3A/KiTURuG3jlFSMhGgSvQHJg5iQiXqIlxaj3KxhEDYmLy+oc4ezGKbVKY+5XCZcuJqOuHcnGfJzgaqQsO0kTm2xIIjvis7hqaNue6OVzrV1rUfLuWql5CDtNKUc1ZD6v3dyhp8gxLCNreqGn7MVMTFYmSazmAHFgxqT3QSbuGO8T8MUapcpMDQeiEXr2x+JQ71emmGxe6QVolDipOkXDfLfW26YpN+IwVpzOWdoVFiTnSiK2aAt0UaqlMbmZqXm3B4c0PNVxqbEjUG5d+0DmOrwkjDzzfRXIOEIFapm87ZK0jGDW5JpohNrSMdJQ6igqrdklMFLtWiTm8bkHw1idubmJqQfK2alS3wLtD1RVP0jPTDVJbnZH61nXmPHd1LPcKa57ZlIlAvF2e9A6VWG3HCZEtTZ2EHmqeHsVS9UpMvMiNu0H1geGPWsbiYZyl48ZmmLuhTg77eGanrDf26FjKq/Jci3UWtVmWcOooJtLqTE29Lm04OyfyjA+reh7N9Xps1TpkbhcDdcsrgqmTspJvSDhEQsHGLd3hzSfB2MTmInKFjR6mzI5tTG9s+rNFK47Cs0eYbYtJ1wNMPND8SUAKkzKzDhevZLijlFkgBkTHwwj9lJ9kenMcJVuca9TNt2vtHsij4slYxxT3zmJOpNfWgXAe5GKxTGpauTUWBvEyhuLs574xWkl6VCoSLlxWm2F43d8FP42/2rzE/pRwcy44y8xN9sN3xgsKzRzkatMRYv28CiFnXl2V0CkzEWJpuDnLDTE/fvVjE0lLjVG5lvSUwF3xHfmlbczB1EuFy2In52vTEjNjabPKZcePBb7DjsXB1Fn5rmNepp0/GgvNER3lGJH74rpGEiuG1d6skYnigV3aWfmCj0gdOm5aaYC4kBngi2Q/aXSrmkZ5bleZGNukVXlw9WJK82OnmXRJwjEVGWZEVvLBTW+0mlmgpvFaPiQWaL1yNTHKg8wNz3iXWtUzZqKAX0cfCiThQttFCaEURZ/FRLPVyrlNeVV8MjjyVfknJPEtNHOcp31wD+FYjzQj7lqKfOtVCRl5uWcvl3ggYx8oqRzJwSAhuE9MYFwyWJwsUcN4kmMNvl9CfzmacZd0d5t/BVrtCfxlpqhh2lVCaKZm5Fh1+IwGJlxLLhnkoRwlQv6NY/T+9GroCPiSElnKuAUsIUP+jWP0/vUfzToX9Gsfp/ejxEoXDjb7KrlnASOEqBb/AIPY/T+9L5p0D+jWP0/vRZs42/tTSdt5VXLOAv5p0L+jWP0/vVqRpshS23Ap8q1L3lmVnay71Y2sFG46A7yL3rdZSz+NqwdJpubA3zr5bGVb6ycL9ysYQpEKJR25a69+Ot9zxuFxis/SC+cmJnq25cVOkijLyMC4FHtuf2/1VsmzPwq8cJUatUG6bJzU5NlawyMSj+6HvQ3AVPd6PMVupf4RqRXxh/NNdgPuQmsFHEmKG6SOqnSBQenO5xzstreDkLaSVOuu+0nEOpR5wu0qS6JFyqVM/VjbaxZQ3pu0WLH2WjLgLxWW/GIwKEEFlWapTZOsP4meI5Doxi5B2Yg5B1yMY5RbHswjDdatpOSktUJUpablxeYPmA98Fj8NUSSlq1NSFQbdmJqRLbSkX3COGxLlIRjG3MY7o7lSUOHqhhaoUGmy9Ycpzs5CXbAukNwA84Qy3EUIZ/BGmcMU4hvo05PyQ9UZObKIfkxjEf0KGmMNU+tTFGm5dp2Sm75qTgYwjAY/hG9/dHVBXHMK0RxzaNSPRHfHKuExH/MjBBTqk3VcM9DffqBVWVefCXjLnLjB7VwsIcoRj74IfOVc66PSXentU5x2MtJ0+XLZvTbg88TKEdww1daMPYQkpkmxn5ypzzTZXttPzUcgLqKEYQgWcPOKA0lmYkSk2WJcpmcoT74Oywl6x1h2OYuhnx7KBFKwpbzYlLzWG5pz6iYKd6RLGUIZ2O5xyhmtphaqhV6O3MkIg7dFp4BLOAuDG0so927cgtSxFF2VcIcOzT0m2MTfjPjCXAcu6B80UcwpGUdocvMSlP8Ak9p8dpBjZwC3Pryhu3qZ8KqKXWjksnj6mzAy8rXqWN1SpRbTL+da7YfctdbyxEk4jhaIkXwWKwp0WpsVamy8/KERMPhA4ez3wj5wirU9KsT0m9LTbe1YdCLTkPKKxOHi+amLnqE5upNTKL8jHqBztt/uW+38wqJVV8s4qoj+H65NU9+4hbK5sy7bceUkKXffTDhr5ZoPyhLN3TsgMTjbxca7UPhxXAl6KW2hwvXWSSSSVIJJJJAkkkkCXrLRvvNttCRumUAEB3xKMd0IQXi6v6BsJ9OqjlenW7peTKxiBcCd7/xYfpU3trGV1jacOrej7DDeFMLy8nbdOH62YMe05HjD3Q4LTCUS5RTm/tfBSCWq0l8607cvZWupCPwUn2tSjIwb+sK0faVV6sSDH1jl2XUG9SCFykHJzlWXnMVNhulmfiaBzmJZx0iAXLPIBVVpM9Mm8VdCedaY1OuAH2iQmcxLT5bcJbYu4ViW5So1As9m6RR4XItJ4PmX3M5lywLeCr6cV8ynebeIWJrGDpaZRkQ8yQl6q1Se0bR0vIdy1ErhCWYIYuXOlDxI43INNFmLYCSbVr4g1tbzLn8vhqoTpDFzQMeMSRqVwe22I7dy8oFxWybauUmygKmfknpVaQEydHlpYbWmRu7yRAWoDp5fspxDHxfkp10Llzm0t1N8h+9Ic7tXWnFl2k0i8KxREMLva7krvZTSMO0Sr7SEN2pEgcnT2jmiddIS2nCKKFLw2LjTnJEd0PDFZ/FVVYpsiybDZDsyujHqV6i16WrNJbnJYtJ6C9mPWk3m2JZWsRmE0nsG7hEtMC1Q8+9XKlNtNyu2uHas9XkuZ4kqs3h+tS75FfJvlsnbe6PCK00rNBUh2IkJnwz8UFHaq+MD0jOtP7N1ghID3jH9iz89iMJSrNg+5sZd8+jld2S6orG0N2p02pVSQdEhabPaNezv3w+5aTEFMhiLDrkSZ1hk5f17kY0kxNQnZFxkiLbhu08Vi8MYqdamJ6lTOqYlTibUS7TcUUoErMttypuEROwGwo+cFJWMONuVxmqWjA3B1dXDdktr6P2o40aOr0Ep6S0zrORQiPfDrRDClVdq9Plent2m4Fjn2ofvRykU1u16WcHTHRH3R61Vpck3KFMMtasiu+7cnTfTK4kw+7LYolavT7mhMdk5DxQjxWykZQ35Upeb3g4GWrzUlYlTcZbjdcMC3w8oolJ/ydsx8P6kzxlnbF4Uw+Ei5NSxDaLbsbfa71oK5KsP00QMRImCz8/JOnC2Febj2Hx/THiiTkvB3aHzFEIjl5p3EnuFOTZhsWXmxtOOkveh7Y7CsTDTrduvdHxQjw/Sr1BmLmXGi7BWxu71HiSbaYZlyLS7A+fygneDpaFoH2XpYuYxthHzUNDdgQ6tOr/cqY1eXYnBuK4Y5R/KQGaxAFPqU8Dg5BArh90N6VrmJgm3MSLYokok4zNDy3bEvjvSprsWBcabLTA8s/JCa5iJuZocwbZcRg43HzWTkcUOFVMhK4YiCTTNYk3xaWs6dsCeaK0nWT3/ABiiWJJuXGkyM1tBIm34BH7JRXK8dVpxiuOAxaLr4QPy3blM5UHJvBIndcd2r3wVTXmJZtxMKeIhk2KoLzREYRKN0PDnFaLB2q63lWDmnnXabParjgIFD9C3WANTYxLwq6djWPMXCgNQD1g3eJaZ7O3l0oDUNTg6e0u1Uycy1a3p1K421pzTpdqNoxtVgWokqFWzVnamuD4Ve2Ue0mkFu61akHmGo8yEvNR2i0kwGlDXJeJOLpWyZqIUYbZfUrxaeVRyLWzZG1WCCJF7K59tQ3+JZvG1Hcq9NbOQ0VKUOD8o5w1Q6vitMQwFQkUFVWSx41vFto3YVaIuuPT24J3y7i3+qrX5+2tUWoUrrV0/4nH7ZP5dxZ2sKj+ftqMqxir+qo/n7a2BFco4p/xn/WVGtYs5RwqP5+2m/LGLC/6rj+ftLWCSRFEVX/GMn8r4r/qqP5+2qdWdxZVZEpD5Dap4TGQOTHS2z2Yx5t0I58FuBKPaTSGJIB9PkmqXIy8nLDawyEAh/vVXFVahRqG9MiN0wZbJgPE4XL+9EnB1KnXqY1W6LMSL+m8c2z6wKHKS0UcJUeNGpYg6V848W2mHONzhcd/ktIJaeVZfBVVcqFPKXnysqUiXR5gC4lGHAvitZ2ebStkqjHmzFSXR7SaMbStt+KkIvxlKjd3HtIDiphxgZesygkU1TiibgDxNiPOP3b4LQXR/BoXiaecptBnJtoRN8BgIwPhmUYDDP71IhxFKQqtFZmqW5fNM5TUm51EUIZ5e4oblco821VaXLzjHI8OdnWMeBDH3R3IPScNVenyLcrLYiMGG87Q6E3GA5xzyhnGKr02UncO4gl5RyodNl6q66ZQJmDezdgN0SHKPay3qhsLdmOpD6tSJCqky5MiQTDP1UwwUW3W/cUN6JWxLtKrUJs2BKWknJX5SMImww+WW0t48N6kDWcKyTjzbk9MT9RFssxCdeibYxh127oR+K0lp26eVCaBWAq0ntdmTL7ZxafYPi05DiMUUucLlLSplVTtlHtEnW2j7ScIR42pX3cqxQDjShRrtDJtgrJ9gtvKODuiDo74b/PgpsFV/5eoLM0QkE0BRZmG7fq3R5v3qrjytzFLpLcpTdVWqJ9GlQHjnHif4qLYUobeH6DK09j8GNzjnW45HmL71lvDOxQSiQldy+0uT1T0PS83Uph6Sq3Rpdw4mLHR77M+qEboLrjYGI+s1ClstOZfcsrbXw2a7eXG/7isf6e/9F/8AInD6E7v+sFv/APhf/IuyCMezpFSEFqfUt7Ppx6cX/uI//cH/AKL/AORO/uIw/rF/6L/5F2YdRaU150GW7nbU+rb2fTr6cd/uHR7OIP8A0X/yJ39w3/7g/wDRf/IuqFU2rfViTpeyq71VcHl2TP2t8U+pb2aVczL0G282IP8A0X/yLqlFl6dh2iytNlitalwsh3lHrKOXXGO9CXqhFxy1xx10u4dyUuzOv7mJew47oXDyqZ2t5K4r4gacrDAj6tkj8y3QQ2crro8rgteQ74qaXwvOvufSZi0I8YXI1JYSkGt7gk6XHUp+2vmVfdbpi5ibmZstIuul/buVqVolRmS1N2BEeK6NLyMvLN5NtiKk3co8qn6sdQae5YuRwfAbYzLl3fBHpOgSEoWbcuJH3kjAhdqJQuc1y5z8kz2qtIgm2W294janDnd4U0TPtakrokPhJQtNuEdSaPsqHl5dWab0oG9BFqRq1tYDq5u9N20C1coqq47du5RUZTDbY+LLTCCC9fpVcnY+HSqcxP6fa7lXcqcBG224vZRAwToWlFU+lQLT2YoSU8eq4bh6k1sJiZ1cgdUUBRyYbEdRfBVDn4QcjBVugHdmThEUVKMpCAQhEM496ClKhCrS7jMy3e06O6BecFk8JUSbpE9PSe0tYM45Q84cV0ChMmMiMbvWhuzTahKxaqTbwjpPIox/WueygPEGH2qlSbCH1rGuMfEnYfpTcpsTHw5Q/FWqILXMrbgMbcveg8iB/TJbaWmG9v4cU6Cq0ux8rMv2iImOr2ox3K9Jy7Tbb0r2d4wh5RUM4zAZVsi1WcLvNSS70NpLn2nBsj7x3JPiJO1Ony5tNvSzhXOt78y74R/cr1WHa09t3lFsr/gq9SmAlqo25dpPj+NuSZm2H5NyX2l2V4RVdwn3C1TXQ2bJiVxRHLPzgq5MtyVWv7EwV2XhWVbxE1JN6iEQA84fHcnYkrsHJOXmBcERiVv7UivLNuGyGYB+XeaLdlmHxQ2nz4bMm3HPqT3e5Yem4nObnHGhK0jOBQ+KBz1bdbnJhtotUCjCP3pFOJgm/iXSsVTbAybL91pgUR0pS2JZcrQFy0t2UPgud1idmHcMtuEWqDsEDos3HpzLjjmrrh8VWsYhOZzltJrEcafUJoWy0xz+9KuViM9ht6Y7QFBYXETsWsRPRcEyE8ihBFpd2MzhmebFuzIYFmXvVcZhPKrI1h9+ebK4hE9MI+5NxRNOlVNk6WQ2WxihNNlJsnpUi5LtyMYkp8X55s3Ltwwzit7kxwtSr0HcMvMiV+m3P3LI0mYg3PM2tkWqOcVvJPDv/FuYtKwojnCHiQ2h0dvp0uPbgR5w90FG3C9eWfxUy6/NNmHh49YohQ5Sbdw+5LldZHOP3LQYmpsvKCUyPM5us8KtYemI/JIywt3bUI5mkz4br5AcP4f6S9PMDqGLUPvzWiwk1Fqcca7IaMvcjGCmQbKsPiNrTY2/HJUcKjF155/mvOMV1+LtM9NI5HSg80MCeb+0jDhRt5UPcGJTDem7UulQQEIWjapBG1WG2YkI9klYGXgJZkmylUQu5VCTRjqJErYXaRTXBPw2imwEuMQcFU+ix2ncPcj1sSHTZcqLwOXZlbculbJmDpUICIiKmcCI6rRJOZCBDqTXAtHSSkVSytt2arkCtEJ3c1yjc1K6ucqpaU3fzKQuZNIY9kVaULnKm3QEdXMnOQ8RKMgVpObyu1ak0ry5Ut47kro8UDrI/hCSIdSXNzD8Ui0oI3Mi5UhvtIdNqThw7IprPLyrRjcTNHQq1L4hYH6OeUvUAHwx3CfwW6ZFtxlsx1AYwiMR4FDvVOclGp2VelnxvadGIFDyis3giafp8xNYaqDhE/I65Uy/CsR5fuWyNkzq09lSEGpQiUbU4icLUpUVsB7RLP40C6jtskX181LNQ+LwLQXRQHFmtyhtD26mx/mwIv8AVRLSEMBHmWbxIUG6ph2YHmCe2X5TTkFpLI26iuWdxhkLNJdEfqanLFGPlErf9ZTVQpWKq3Sae9OTLbptN5ZwaG898cuHxWXrD0xOSNeB9wSnKNlPycyI2RGERiYjGHfpIY98FvNFqytYohk29TpAdlJz7sX6jPuuZxFuHEIZxz3w3Q6oQQOpjtuNL2BtCpUxuZdD2gKA5/klktYQxt0ksvhgflSsT1ba0yVkJOTjw2jYxjEzh5EXD7K1QhdyqZVUrTt1EnEcGGyceIRABzjEuAwh1pzYadSxfpCmHZ6ck8K00rX5/XNOD+Cl4c0fxlNVSjwYDmJsRTWKpkfooZytNAuy3DcTn4y32/7SHyZSVNk2ZVgRBhgINNgPZhBWOlvuWwlpci8y3LJsVWLnCLVyprjtpait+0qbzr//ADmYaaHuHiqbk3KNENouzBR8XBT/AMMixVBtvQIk79lRuTTpam2bB7zJUWXahN3BLS+y8xFXGcOTj9pTb1ufV1qf9yZnqFV6Yhqi7NF7gVXpFz1ktLkZd5rWSOGpdofWavtIpLyTDA6WwFTvVWJYlmm1Gbt07IUSk8KhdnNuXl3LWE1DgP3pbG25T9aelaQHy9FlmCzFkSt8SJNtQ7I8ErojuIlGQxL2VG02VqkIY3aRTrreVR228xJrxQbHMi4qVJs7h8Kbdd2VXJ2Gnz4J211c1ooxNfbpFQkV1sSJNceBscy0iqL06Furl7kSuXxFy0hu7lHfqIbrRgg5VOBFcIquU1MuOeoHT1ose2sB7XZQ2cqAC4IcxdSriy6WpwvgrHybdv7XWgq9ONzQI3ZJWTDheEVeGUAdVtqvMshaJjqTYCSlD2fNcKsNyGn1du9ENhC24eVObCIiOm3NQIZeSC3luLrUhSgEOVvtK0QxIebJOsiJeygqwAB0kPBRusCcYQhw4q5Mc1vaVU3m2nIiR5F3IB9AmoETkC7evLw5aU2vPG2WotF0IQ9nNZGoYibp9cIGiG2OUYfcoahX4TcjMG4XIEYw9/Umk5c9+m8+UAck2zbIb4j+pZtyrhJVAoOFqjx9xLn8hXZhwbGy0wVPEE3MDNMmRfWBx9yuKap3zDphVuXnZMm9pyBHKPnDesm9io2HJf1nA4R+/igOHHdp0gdpdlnlD3wWbmJiIkVwkRA7w9yVrGCbTw6NiqtOAzIvXaXBjl8ELwhV5t2oPDcVvX8YKriR6M3h+n+rtdbK2H3KvghibbrDhkNwQyzh8FvSe1GpTZlMTECctEHeCMVo2ywyyYkREBwzj74IfOUeM7WJ4rcgiUYrSTFH2WH22S1DEoRy+CZ5Vqy+GprY1Zk9ndlknVZqYdr010blif61rKFSAbmGztEggP6VYKUalqsJFqJw88vgsz5NeAPoDpYXmGny13hbBVaDh8ynGXebVvW8nmAcprkW29QDCMUJwxMQc9cLg2dcPcpzw3AbWKZAq9e4N2oBRr5KaKjuA0NuY8ni3oLiydCm1iXccL+UZO5e5HpepwGkzDrZARA1Ekz4bgHpjTTjbbWkcijy98FcxFFhiVkzK29wt8fcsHhmv7Ry5zqOMYfGKuek6q7L5FZbLs7SPxTuTHDoG1tp7LbQjdbE8iWFoNXg/XHo3WgBH+lTUKtX0mamn+WXYjlFc5w1MOlPXDzOF+uKY4w10L0lVUylZFoRsNzj7lqMGOw+Q3HnBHZMtcfcuV+kCb6TiSXk2iIyYAAjAfEWS6xTaZGWw7I0rUDpjfNx/wBVVWu0tlHJuxpOD3mrrpqeOJlHwwipsHMbOXSxEx9FEG9OWmCtYaC2VES6l6a11q5zOZFiG7fao2WoFMNjy6lMQQUkq1dMDduFAWGVtEU7d4RS9X2iJSerL6sdSlaMhj2dKba5bkQ3CrBFbzDcobrvZHuQU3gAuYbVHbDs2qw8HXaq+tsitbuVIObzLmH8lRucymvctzIbfJQkUCK7lVCu5eoXPaVgs+yoSL8lXVMq5FBNuh2SUhbPwptniFW5oSyUdsPF71NddpUZNQJaIyyu9lIhgnE1byikI3coqkkN/itSLSWrVn1p1tqbb1IISGFxak5stKa4EOyVycI2jq5VojLm08qzuOpB8WZWt00bqjTS2mXja7YRWmHK7l4qYhuG23Sgr0epMVSmy85KamnwgcI+HvhH3K0RWkXUsPQ/+LOKHqM4RwptRKL8lHqAu22tpuu7RLNTKS+N2nlWHqzMtVsTVBmqVp+nhIk1GVBqYFq2JN5kW+HHfxW8EIkOnqVV6nyz721flWHT7zbhGP6VKmRGmUv+ulW/yqP7k16hUR8RB/GFRdCBQOw6m3GGYxzhHh3rXFTKf2pGTH/+Ef3JDTKeRerp7Bl7LMP3JsaqeCJg53DrZvzBTJwdfCDpFnEhF0hGMYw47oIxOSEtOSrktNt7VhzSQFwKCmk6VMkNktLjLtQ4Q4Q+6CsdEYlhun5zhxgKibx0rHtXHZyzYg2QgADaIDwGEOrJObdccL1TJF3JfKFPYL6NKk6fVEkum1Sd0MS5ND1REVH3ejMK9cmnKRS5qfn3Bl5dgImXeXdCHnGO5ZXAEk3sZivV1wiqlTK/Z/zbXYD7k2epU5jDGzeHycI5Cm5P1E+q6PI1/b/VXUJPDEoxbtNZQSbRWMTJibeGdGe0lCn08RKHWQ5qYZCqz29wiaGPGArZNyjbRerbCCsDkIrlPyxXxDpp7lk5DCuoifeIg7iRqToshLcrN3mSKW3fZSt6x0iuc/JNu16RVC2yAam27fJTC119pK+1NF1QpJbC1N3cRFN23VcoXpjqH4RRqwRctv3JXfiqn0i4bhL4qq5OwEdRW5IgUIg/3qEnUFeqrTblt3FD3Ku645YwyRF39SDTPTYNjq1Fy6VT+UIEWq2GXiWfun33ubIVMNP2jnrCIiQXnqm0LnNf9lQ9LmHyG0SEVYlae2I2j1K42zG4hIbQ6oJs3ASTUy6WRucd8IKYafEnNV11qLNhp0jq71MLURJQoNGQabZ9YP5KsS8rEXLNnoj1q5ZDVG5Ouhp2iCrsIC5p1DFWNl6vLTvSsg2WkdKdaFvrNPmgbb+hRiWq4dXkpiKA7x5VXI4CXLxQTNnARy7+pOIwJUSfhwHV5prk6AjaRCOSAkLsLbe5VXJqHC5B5irsMDmTnvQeYxA0JZMiTufUg0zk3DiJe+KrE5Ayi4UbSj2u9ZJydqMyRC3a0Ed6bsH3d7r5wjDqhwRmzn+Jr5avNi4VxWcRRKVKMzTZxu3sRLP3JVaixbrDcHCIhgMMol71rCpDYyLgtjqMcsh7orply1c3oMvMviWzHtK9XpJxwpVkrroDHOK1mFJdhgngt4acvim4udalhF4R46Yx6llrFaheHKFFgppxvSQeL3IXK0jai446360zjlDzzWwwxOtOsuCWq84Cs3PVVtvFDksJWi27apiZwrDSVyitfJ4mWkGciy807BwALk1G0Szyyj8FXxhV2msGzj4lrugMI+9ZnBlfubECK0jKEIxTnBgeq2zlq480Vo56tPmjFamGmsOzB6bWwhv8O5crxpWjbxtMC05tWm8ghEVcxBXTLBswJFrf0Z9WSY5a1WGK+27Jti5zQGCF4yr4SWLGW2+SAQOMFicJTr4zDYXXByobiSpnUsQTD3NkVufuWDrRYli5huqPs27mrdSwuEq46242z2olbn745oTVqvGUw2Ms25a7MHcUPKCo0OdCSIZktQs6owJBovSVUIv4kbEXCIWWoZezmpm66cjheaJzmdDZDFYFyedqFSenHSuJws8lHXKrtdjJj9U3x96A5hl215uBFaN2+Pkliyuwq9eIx1MMjBpv3QWdbqGwlXAaL15j+TBDWahGW7N5Q4Lcqw3FSxBGRw+VNaLXNfWR8I9yjwx0i7bsM3k3qH3rGzBuzPry1F1rSYKqDrExs3C0GjW2wVhx1+tfKlZeHpF94hx3rrkmMXHsyLV3+Jc7k3oMTDfhit1h+bg6WycLXAc4R8l1pOrnMFXg9XzK5hxr6PqUdazIht1ZeFEqEP0fUvR0ntaFmNuZKSVCIuCrGamlSb7Q2kueyqprY9lImokOq1SCcOHZTfVkpahst3ik5mQqa+HBRkX5KoUyGPiUdtvaViYKJfg9KrkENSqrDbbR5rlCQ2qZRkWn3KkoXM+KhIYKZzUoyHruVpRkN2q0RKCbZd2kiH/eoyCI/Vq0lZ4tSa4ME4RimuZrUm5h7RElbcXNpTrbd6bFA23UQqMi7Kmvhcm3gqSj2ULbkiG0fEnE7q5U667lG5BHZG4YpxDcKsMy77ultslcbo75b3HBDvXOflhVaSx+MKH8r0UmmCsn2C20q5wiLg74b/NSYQrbdbo7L5N2TUPVTDfWLo8YZfpWsKXpksXrXLzh1LDzwVCgYumqrhKlhPSs+1bNShuQbgLo8HBjHvTebeINdWuZlJl8vUskIw8SsN0hxvfOzQgPXC5ZEsRY9m9DeFbfIZ9uCbZjx8s3cH3j7VTZh+1Rz3Ks+obC+kSnNc8UOCaVYcc3SErb+Ks3KljFj/qA0f2qqyijdYxwwIi36PmBH/8Aasqftr+/+nIo3KVebcGL7loR+CtM4Xg4Ocy8R9cUJ+cWPh5sANEPd8qspfOPHw/9QGv8rsqd7dYViO2ulaRJsWwbZu8yQ3H1fDCWGXpxlsTnHCgxJsCOcXXi3DDL9KC/OX0gcvzAa/yuyoaTSMQYmxpK1nGNLGmSdKa+hSQzAvwJ4o73IxGMeH8K585zaeFfqIHvRthqOG8OttzZbWqTRRmZ50t8TeLfHf5cFqCKHFNeLVbbwUbkdQx5RXOZzOZXWNeE18bU1R77b+0oXHYCOpzUsE1xjzJZ9pDZifaYEtsQ7kJexA0JbK7zhbv4INI4cNXiUJTXq/a61myqUw79UyW/rSbkag+Wbsx6rqgKAo9Umgui44I5KjMVtgXNkIukVucLRUjNEaEdVx993aVzoUGrdm2N0fvQB+kT7rfq28gj4khpjr4+teIiWk6PpGBN8VILWzGy33JsrUBbpAC2MLrit3RLsq5L09tpkYN6ij1+aKCGrMhuTtH4AVDVGXlLhICHVDVn1K03KQb5eVObDa3RFwh71MJwG0EEbDFqkEICWac4do28oxUZZNiNpakDiGDZD2VXmHtk4Wm4YcU4pjTq1Kq863MiUHBtKHCIoLjJg4N7ZXd8E7OA/a9pC2SCUZLVz8VXmq2w3dAi1IwYedg2Or4quU0BWiOoYLMzmIgQd6tPul6vT9lGbNxMVJtsdRW58YIPPVhsvqyu7lkymHX+YtUE5tmJFquVsEJqtzBFlLD8VGT02+I3FoTW2tj2dSJNsaRjzIKLcrAi9ZcXfcrTMuAlpbAcutXhHVaI/FSEzHTcSCuIah0qYGcyKMR09Sm1jaTY3Lw3SFyImO6HBQOfYum+hTEnFxzU+7nCPl3I9I1hh1xuAuaruPhXK/SVUjH5JYEtQDF3z3puHKnFqTmnnSt2bUYw96ApS8VQaq1QG67N+Iw+9WvSVWtnheTFstTrucYde6K5fT3olNEfLeUY5++KIYwqATr0nLNlpZDfHzig2mDK7tBZ02i3qKPuWLmqm5N4qnJkS0m7GPwz3KGTqEZGmzEW+YxsghdLP1mXMfeg3GLq2ZYVk6eJaXDvKHWhOGpoJYhNwrRAYlHuWdq0w6/ODErtG6CJNyUy/TfV26x3rdm6qvS4zlQefItUSzgrWIqntJeVkW+UNZe9C5MQlJwRmeXlzVysSku2O0bIiKPBYo6XnYy0q48AkJW2wtQmRdumLnSszLOMSVim1IxEmXbSCPBDZwoEVqC9WNo5ODcQ2QHT7lC3Og625LOCQh3ioXL3GRjzZaVHLtXPCSCu47Fu6DRWqZw4usjdzQ61JMSkRczFTS8rEvisA+XZjtM1NMSUWyGNumKJNyWzctRToG1Zt7Vq0C6WzcJAQ6Yq1LysZaaEeXJWqdK2uDDuRyoSEC2bw+Heg00qMJumtudsBRjD0+bbjbhFkUN0fcg+HMykyZLrFKVzZccHuVVQ6Q568RIC49aOUlq2XEbVmcHTHTZWwtRNraSYgI2l8F6K24ZghG4lYbzHmUg2EOWlJtqAlnbcpaV3h1Jt58tulWLoClnG3s2oK90OA6c01wbh0kpiyLs6u9VyyEuZUK7hRHcqpaiVp4oFyqvbESzXSqJK5NIodlL7SjItXLpWpIigXaVWYzUjn2VG4Nw8yqqZRidqkI7t9qaLXhThy7SsNth2k22BaeZSC1Ei0jcpmaZMOfg7RUbxXs1U7IW6hSIQG3TqRxuiW27dy1SF8lSX1rgkSz6vqDT2AjLxcIdmzcUVcbocwYjG0QH2lM9iBpsspRn3RVf5Sqs65k22VsdKz7z7VxyjyzFsZmYESjxUPTqfKXQab2uWnPqUbeHJt9zaTzhEKMSeHJZhm3mUTr3KueoA/lKbfK2UZEBjximlTKrMlqIhCPtLZSsg00NrbYqxZFvSX3ip+tFfEK09yyslhWF20fcu8kYl6PLND6tvV3kiQlEt9txQTrri1Cuc/Ja3aq0iqFtgG+yIipBy1DanOHDSoydhdpULSWgKRDDZ+JVyO24SJN20LhgJILhZCI2lqUZH1oe9NN2lcSpzFVlxEYuOW/jIkaJ4G+YtSruTENRLNzWIGnPqriy6h7SH9Lqk256hkgCOnMkGucnoDzFcVqGzVdl2h1PDDPlQcaJNzLlz7xAPcKvSeHZRsc3R2p+0gjcr7j7ZDLCR5Duj1EqLI1ebcK6xoFouiA282LTYiHXAVeJq0mxt/wD7Js3Vm28PxdIYzcwTpQ4wV6TokowVuz1Q6+tGiC26H3qSwOLeouCnZuoe3KQEfVjaKsC1G7Vyq82FtxF8U0rPteSxqMQAtJcqc3YV1vNBOGwtPDLrULggW8ebrt7SBPEezEyLT1wSZOBfZgo2xjzDqCPUSV0BbLZ/2ijU1/N1JXQH2u9UelQEhBwdUeKhmKgANlEiEeyiVxw4E4MB0j13JE6Al4s1n5isNWuXOD5IXMYi2Qjbqy4LTZsHJoGxu7KplUAbIjJz3QJYOYxG4Q3E9oj1IS9V3SErSvGHFVqzZ0CcrUsBaeZB5zEkOUdPmsaT0y+3m2NpRSboUzO2m5eIw4xRnItMYgcK711wx4QVEp43y0tkPfFXJHDsLhEh09SOS9FbAea3NGYZvZPuCI8w96IStNdtItQj3LSMyTTW4SvLqtVhwIXDcNuSK1B5OmR49/FXhktmVrY3D1q4OVpDy+aaLoNlldb3oxCMuA6i5faThOAlqb/co3HmyHxCoyeg2JCPNHxKBcHLtcsVDMTsGyG7V5ChsxNnzXIO5NNsERE5rjvig0RVWJD6vmVI5pwnIkUSKEeA9yzj2IGmuUdXXFDH8VR2m4gyVt2cqrU7GcqRPOFqhph7oKw90n5LtbErT/zoLXT1CojTPSdmZOw6i4JpTbexEmxG0B3KGMTS5J9wuW0YdZJTlKf2hPOEIiiU1UrZzMi0x0xTapNhs7Puii0kvT2H5MYXXD3oa1sJGcERHRHdGKbT6g4yJM3XD1IfPPRccQGKo63s+X4qvRqkbYuMlqHqVNzNyVFV5MIi8sDqgcXHiuHUnOGbknq5oaVNMSsdpmppWXuZKHegEyQesHSrE1KR2mYirjMpEXB0owMptB1eFaAsnK7Rm21N6JFtwYdlHpOVtIhFXJinw2YxtQBylIuMqOVkrXMiWskZKBN52pvQoDNaRRAS5IXSou2ohTpL6vTxRhuVA5N4BHk1KSns2iNw8CWgKUlspohRgpeBU8dOqCsVJqG2ExU0qMCbyLl5VWrdkNHC0m+z1Kw4Fs9MDbdpugmy7UWi9xK04P0gT7xyVYNl7BE7BqsCyVwifV5rrEvkI22ri9HLZVxly3IoFCOa7ZL5EOfMr1YRBd2RFJsIXarhU1vi+Cd2tJIG7L+b1faUZXj2VNv9kU0jj4kEJHH2VXezItSsOFAVXc9lVViu4KhIdXuUjhgHMqpPQIvViRLolJfbzCkT0E5uXmz/AAdo95KYaRqzm3NKneGYlRcdb8WruUbYG79UyRIoI0yUu5SJQuV0BG2Wl7hVbWnxDJwTdFmXbYl6r8ZXBpknLfyl7X13IWU7VJ4rGBIBTpeiTky59JcK6KmYn/KT/UCD1Sp8tpaG4uq1UXq7NuuWMM8UQk8OsNkMXRuKHBFmaawz9WNvepzSqtbWZUZeqz31hEAK01hyDhDF8rigtUIA2NpfBIWoXalM/NPR9OOwuXo8s3bazcUN+pEBZt5REVNbamkUG9/Mom02XrCQRBsfFmo9Aj4VHtgbIQu1R4JPFp9YOrqUqOI/WWp19u8lTcmodorSgqMxUwHe5ydcUSMbaBDmIqHbwt1Es/PV1tu23TnwQmaq7hOeruIYINg5Nhdq6lRcqDbd2z/zlmyKozeti4Rj4lYbokxMtiL5WFDeguTVabuER1lHsCqr1SftKDDeZQ+5XpXDsu3vIbzjxuRKXkGAK3Z8OpNm4Znos3OtjFx6wY8YcFabw+2Wz2lxD9rctMMu1bqG0upTNtREc+Aqdm6g7NKaaJvZsjbvHlRBlmDW623zVi24vZTiGHC7Usaj2Nw5/cmi0Dem3V3qxdG3lTW+Ui7XtII9lDaXdrgkQGVsCLhvSIojzEpNrC1AiCJFmKa2XZLSUE1yatG0RVVyYg3d4louCXaLTkmifs2j3obMTUWm73HLvJDXq6w23nqIvAjNhwj2Zc1wxTZiYg2JcoiHBY+cxFzRbHLLggtQrTumG2u6+ZNWbNw9VWhErnLTu3xFD5rEEu0Llpe6C57NVcyuMSLeVsAH9ahZOZdc1Dx6/JVqZaqcxQ4RFsytKPWKBzlbu1POF4fiqsvSH3XM9XlBGJLDF31g36s43IkBKedfc0iVvUnNys+/9ZpDrW0lcPttCN2ryVzorDLZaeCbK1Yluixct2nLBFpOiNiVo8tq0gstk2OnT1JzxNC4Noqdm6qLNKYFsY8yuCTTbbYiPDinCcWxLtKmTrbZFG7VHisasOC2RZiWyySJ7Zt22iZQQ0pgCcK7Vmq5ToNCVunLxICgzRjqtt71H02PKReeaAzVVg2P1l3khMxXW2xK3SSIa4qhC639KrzFSbb3l1rn8xiKJOerK4u4d6r7ap1AvVMu7/FugrG2mK623ykg81iWAuXfcgvyRM3Zzs0Id8BUwyFOa3l60vaW1pKdoQzVdmJtz1Nx/YFRlL1CbIdoOxGPWatdObY+oEQFU5yqxIhEl0+n7ZssN0iXEb52aIy7h3KUY0yXC1uWhHPfGMeKBTVSiQodGbOMc7k1g5WatPXS/vWfl50xubItKTxmUuMblRlx+kauted2QzzsScUzgmUqMVJNSvrNKsS8vdLlBAJkx9crE1K6s1abktm8KLfJ8HW/cgEybG0G1TFKQbe5UYkZLZue0rkxKas1gFjKQcEtKdIykBLJaKVl4W6hTZWXtmCQD3qbC0TV6XlOW4dKJOS9zamZa9WPaVaoBRlINzltqKOSkdmWngppiXh0hs1eZG64CLiq1bsFyLVokKdNSuzJs7bc1M2OycKHtK1NDtJVuNt2pbWqcq8qMLnB79KjENmOnUUCUkuPrNKcTURItXaVap2KcGBSonbqgShlTgT2Qok4F0n7iUMq1DaDcq1NlOYEx5S1K0y1tGxu5lYmmoDcSkl2rm7vZVamyjLjbPNx7UCh+tdkprsXZVsyG3TBclZajti+9dQpc/KNU2X2s1qthnAVV4KixBEuUk0Qj2ubvQ1ytw1dElXZjLr4KMfliocojKB+lc1ixaR1Fb9pU3qhKDuIri9hNGidqfmidL7WUFMJUqR3Db+tP9J2VSefd/k0uRD3kpG6bMuan3gAY9QpsxidhsrJZu7Vkh7k9UJwig02UB7hXStLdo3gUGSk5Yh2jl5d5KMqlLM6mm/yVTlaJOulfMuWfaRaXoTTe9wrlMxWvmVVzboLKqzLn1Y6Y8FD0edmx1XCMVqm5KWY3C3wVodmI5CKn6sV8Qae5ZeVoB6SdK7PjBFpekS7XKOpEi0lpH4p13i90FM/LMqrSEbcqDQ6feprYdlNuhsxuJRuEfBY1IXrGyuK1OE4bMfPrVOYKNoj2Y8VX6WDFoXaYcFIJEVxW+yo3D5dSGuVVvsqi5UoloEtXVFAccehdpct8lTcm2x5nLtPBA3JiZLSQ3Z9aa3KOvlmVxIL0xU4N721XeqxvkRCXDgpGaPG68iu8lal6eDbltunrTZuAXbTb5XqQafMPla4WiK0TclAd7belTNhy6bR4Kdm6gI4fafITd1ZcEQbpUuP4O3JGLY/ZTXig0JG5uCA5rGqrbMB3CKmHIdNtuaEyuIpBx4oCRBq3xJHmzbfbF1srwj1rG6qpBcRalIyER1COqKsDl2UiOAkOpA2yHMSbaZfZj1JPPQ7OpR7XVq6utBJZBsdXKkJw1Q/SqMxNAJW3au5U3Kk22OkhHLjEloMbW4tPLDqUbx3c2kYdazL2IAac1Ff3IPOYncd03WjduRLZTU0DY/WDd3KjMVNoW89pcXXBYOaq0XBJ24ruqKHjU3HeUrS61erNm6qFdgHKVowWfmsROOERtuZDDisyJzc2WZXb9MFMzRZlwvWDaKpPKaarsw+RWlw43Ie9OzLvLdv4RRiTw66Tl9toLRSdAYbG8m+CnYwwrMrOTO79KJS9Afc+s1faW4ZprDTZFaMPsp2yY4j1JsrVl5WhQab+ruz4o1L0VtsR2g6UQvAR9WXFQk7ERL1ilqYZWXEeW0YdamvtISHSX7EHeqFoiA8qhcqHVdqisBaYPmK60utU3Jq0vD5khr1Qt+z7SGzVTbuLavXfZW6mzQOTcGxzu1ezwVNye1aVlZrETTXLqFBZrEjrpZM3e4d6xmzcPVCI3XOWj1oXMVqXbu1XFHjBZVkKrUCyabIR7z3K0zhuIjfVKgLXkG9XWs26ZssTWJQHlQ35Vn6g5bKMuul7Iogz8jU/llxmSh23eKjexGYl9GEWfsDkr+lPbN1Vuj1d9z19ssPXEyUzdIpjF3TZp2YIeod0ENnKxMOkUScJDXJuLnMSrStU7S0nTpCSG2Ul2h8y3xVeYrTjpc1o+ysy47AS0kltVW0VMSNOT5luIlTcmol2kPJ7Um3XKZuarTkx7Shceu5k3cQ6lI2ypmysK5ZklsrvgiDcrq5blZGU08qjZrNstjGXyjDcq7DQC8OUO0kkuaxV5gI8YKaWaAW90EklokfYACG2GSJSwQtSSRCJqEIPFGHFXowgYjckkguy4Q2YpwBCDwxhxSSW1FwQhavWYQ2efWkkqYfMBDZtxy3qWRhCLmceKSStKtMhCDxZeJW3IQjIjmkkrFaXCH+cppjjl1XJJK0rYwh0fLquUMpCEJgsuotySSnoWZwIbPPLemSMYxaKHCHkkkq6B6gUeVmpgdttC/GWzlqJIMCOzYhzdaSS4TMulRKBQZKMGgEYQ4ZQQKr1OYYKEWojCMeO5JJX8cZlks9GpTU5tdq7Hdwt3KzJyjTwjFyEYx96SS9PiHCGrpdHktkJxazLLPfHrRMWgC0AGAw74cUkl5rzLvSIOKEM8+u5TZQuJJJcnVEO8d6aHMSSSDw4xFzKHBM43RjxSSRCEjjbHfw4Kicy7C4YFw4R60klTAuYnHoiOZdV3xQ3bORyjE45xLekkgkZCESCMYxzjxReTkmY5RjCOceO9JJS0VblmsyhbuhwVgACFuQwSSULPGEEm4w2mWUMkkkCcjH/OU9kNnn1pJI0w4xG3JRvNA9GEHIZjEd8OpJJYB0zQZC6BwZyKJb8oq8EIMxBtoYCEOEIJJIHwjGG0yTHdIhGHGPFJJBTi8UN8Ms7e5DJ2deuyhGEIeUEklrGfqtQfDeJQz9yCzE07syjEs4+aSSJkNmHT0xvjnvVQnCMYHGORR45JJK0rEtLgbZRPMsuEIx3I9SqVLG1eQxiXwSSQaJiQlwaG0N/f1qwDQGQwKG61JJGp2YQzPuHhDqTnIx1JJKFhzzx3QhnujxUGcefr7upJJAPmJt0eEYcbeHUqj7xuc0fuSSQQPxi3db1cM0Knp99scwjCEfckkrQz05UJguJoM7OPOHCESyhHjkkkjGow3QJKdG+a2rke6JbkfmJWWpgZycsyBd8RzikkutIglnKhWJtwChE4DD2YZIM6+64MbzjHLgkkuzmoOHG7imFGKSSmxVCUYxHeq+cUklxlSOMY259aczGKSSmVpBhCI5x4qdsIJJLBZbbG3grTbY3cEkkFplsbs8t6myy3dSSSD/2Q==)

This Colab notebook provides a streamlined tool for identifying and classifying various types of screws, bolts, and nuts. Leveraging image analysis with OpenCV and detailed product metadata, this system can analyze uploaded images of screws and provide comprehensive information about the detected item.

# Key Features


1. Automatic Image Analysis: Detects contours and edges using OpenCV to classify screw types based on visual features.
2. Extensive Screw Database: Contains detailed specifications for each screw type, including material, size, head and drive types, thread pattern, strength grade, and coating.
3. Comprehensive Descriptions: For each identified screw, the system provides an in-depth description covering typical applications, material benefits, and usage scenarios.  List item



# How to Use
1. Upload an Image: Upload an image of a screw, bolt, or nut using the provided file upload widget.
2. Automatic Classification: The image will be analyzed to identify the type of fastener, leveraging a simple contour-based feature detection algorithm.
3. Detailed Output: Based on the classification, detailed information about the item is displayed, including specific use cases, material properties, and other technical specifications.
"""

import os
import requests
import random
import json
import numpy as np
from skimage import io
from scipy import ndimage
from shapely.geometry import Point
from shapely.geometry.polygon import Polygon

import torch
from torch import nn
import torch.optim as optim
from torchsummary import summary
import torchvision
import torchvision.transforms as transforms

"""# Helper Functions for Bounding Box Extraction and Image Rotation
This section provides helper functions essential for working with rotated bounding boxes, commonly used in image processing tasks where objects may be oriented at various angles. These functions facilitate the extraction of specific sub-images based on a bounding boxs center, width, height, and rotation angle. By converting bounding box parameters into corner coordinates and applying transformations, these functions allow for accurate sub-image extraction and rotation, ensuring precise object localization within an image.

1. unpack_bbox: Converts bounding box parameters from the COCO format (center coordinates, width, height, and angle) into a format suitable for further processing, including rotation angle adjustments.
2. rotcorners_from_coords: Computes the corner points of a bounding box based on its rotation angle, providing accurate positioning of each corner relative to the bounding box center.
3.  rotbbox_from_coords: Generates a rotated bounding box from the computed corner coordinates, ensuring that the bounding box remains within image boundaries.
4. extract_subimg_bbox: Extracts the sub-image corresponding to the bounding box area by calling unpack_bbox and using the returned parameters.
5. extract_subimg: Extracts and rotates a specified region of the image based on the bounding box center, dimensions, and angle. This function enables precise orientation adjustments to align the extracted sub-image as needed.

These helper functions are particularly useful for object detection, computer vision applications, and tasks requiring precise handling of rotated bounding boxes, allowing for effective sub-image extraction and rotation adjustments.
"""

# @title Helper functions
# helpful function for extracting rotated subimages etc
def unpack_bbox(bbox):
  #bbox as in the json/COCO data format (centerx, centery, width, height, theta is in radians)

  rot_center = np.array((bbox[1], bbox[0])).T
  width = bbox[3]
  height = bbox[2]
  theta = -bbox[4]+np.pi/2 #radians
  return rot_center, width, height, theta


def rotcorners_from_coords(rot_center, width, height, theta):
  rotation = np.array(( (np.cos(theta), -np.sin(theta)),
               (np.sin(theta),  np.cos(theta))))

  wvec = np.dot(rotation, (width/2, 0))
  hvec = np.dot(rotation, (0, height/2))
  corner_points = rot_center + [wvec+hvec, wvec-hvec, -wvec+hvec, -wvec-hvec]
  return corner_points


def rotbbox_from_coords(rot_center, width, height, theta):
  corner_points = rotcorners_from_coords(rot_center, width, height, theta)
  rot_bbox = np.array((corner_points.min(0), corner_points.max(0))).astype(np.int)
  #constrain inside image
  rot_bbox[rot_bbox < 0] = 0

  return rot_bbox


def extract_subimg_bbox(im, bbox):
  return extract_subimg(im, *unpack_bbox(bbox))


def extract_subimg(im, rot_center, width, height, theta):
  rot_bbox = rotbbox_from_coords(rot_center, width, height, theta)

  subimg = im[rot_bbox[0,1]:rot_bbox[1,1],rot_bbox[0,0]:rot_bbox[1,0]]
  rotated_im = ndimage.rotate(subimg, np.degrees(theta)+180)
  newcenter = (np.array(rotated_im.shape)/2).astype(np.int)
  rotated_im = rotated_im[int(newcenter[0]-height/2):int(newcenter[0]+height/2), int(newcenter[1]-width/2):int(newcenter[1]+width/2), :3]  #drop alpha channel, if it's there

  return rotated_im

"""# Device Selection: CPU or GPU
The set_device function is designed to automatically select the optimal processing device for this notebook, either a CPU or GPU, based on availability. Leveraging a GPU (if available) can significantly enhance the performance of computations, particularly in deep learning and complex image processing tasks.

1. Automatic Device Selection: The function checks if a CUDA-enabled GPU is available. If so, it sets the device to "cuda," enabling the notebook to utilize the GPUs processing power. If no GPU is available, the function defaults to using the CPU.
2. User Notification: The function also provides a notification regarding the current device setting. If a GPU is not enabled, it guides the user to enable it by navigating to Runtime -> Change runtime type -> Hardware accelerator, where they can select GPU from the dropdown menu for accelerated performance.

This setup helps optimize resource usage, enabling the notebook to run more efficiently on available hardware.
"""

# @title Choose device
def set_device():
  device = "cuda" if torch.cuda.is_available() else "cpu"
  if device != "cuda":
    print("GPU is not enabled in this notebook. \n"
          "If you want to enable it, in the menu under `Runtime` -> \n"
          "`Hardware accelerator.` and select `GPU` from the dropdown menu")
  else:
    print("GPU is enabled in this notebook. \n"
          "If you want to disable it, in the menu under `Runtime` -> \n"
          "`Hardware accelerator.` and select `None` from the dropdown menu")

  return device

"""# Figure Settings for Visualization
This section sets up the default configurations for plotting visualizations within the notebook using Matplotlib. By customizing these settings, we ensure consistent, clear, and professional-looking figures that are easy to interpret.

1. Figure Size: The default figure size is set to [16, 6], providing a wide-format layout that is ideal for detailed visualizations and side-by-side comparisons.
2. Font Size: The font size is set to 14 for enhanced readability of axis labels, titles, and other text elements in the figures.
3. Axes Customization: To simplify the appearance, the top and right spines (borders) of the plot are removed (axes.spines.top and axes.spines.right set to False), giving the plots a cleaner and more open look.
4. Auto Layout Adjustment: The figure.autolayout setting is enabled to automatically adjust subplot parameters for better spacing, ensuring that labels, titles, and elements do not overlap.

These settings provide a streamlined and visually appealing foundation for all figures generated in the notebook, ensuring consistency across different visualizations.
"""

# @title Figure settings
from matplotlib import pyplot as plt
from matplotlib import rcParams, gridspec
from matplotlib import patches, transforms as plt_transforms

rcParams['figure.figsize'] = [16, 6]
rcParams['font.size'] =14
rcParams['axes.spines.top'] = False
rcParams['axes.spines.right'] = False
rcParams['figure.autolayout'] = True

device = set_device()

# Download dataset, took around 4 minutes for me
# 'https://www.mvtec.com/company/research/datasets/mvtec-screws'
import requests, tarfile

url = 'https://osf.io/ruca6/download'
tarname = 'mvtec_screws_v1.0.tar.gz'
if not os.path.isfile(tarname):
  print('Data archive downloading...')
  r = requests.get(url, stream=True)
  with open(tarname, 'wb') as fd:
    fd.write(r.content)
  print('Download completed.')

# unpack tar datafile
datapath = 'screwdata'
if not os.path.exists(datapath):
  with tarfile.open(tarname) as tar:
    tar.extractall(datapath)
  os.remove(tarname)

# Some json files and a folder full of images
os.listdir(datapath)

#Load the json file with the annotation metadata
with open(os.path.join(datapath, 'mvtec_screws.json')) as f:
  data = json.load(f)

print(data.keys())
print(data['images'][0])
print(data['annotations'][0])

"""# Loading Images and Organizing Data Mappings
This section of the code initializes the dataset by loading images and creating mappings that make it easier to access image metadata, annotations, and categories.

1. Image Directory Setup: Defines the imgdir variable, which points to the directory containing the images. Each image is then read in and stored in a dictionary for efficient access.
2. Image Dictionary (imgdict): Creates a dictionary mapping each image ID to its metadata. This enables quick access to an image's details using its unique ID. During loading, the alpha channel is removed (if present) for consistency.
3. Annotations Dictionary (annodict): Uses a defaultdict to group all annotations by image_id. This structure allows easy retrieval of all annotations associated with a particular image, which is useful for tasks like object detection and segmentation.
4. Category List and Dictionary: The list of categories from the dataset is stored in categories, and a corresponding dictionary maps each category ID to its name. This allows the system to retrieve the category name for any object, improving the readability of the analysis output.

By organizing the images, annotations, and categories into easily accessible mappings, this setup enhances the efficiency of data retrieval, making it simpler to handle tasks that require specific image annotations or categories.
"""

#Load the images, and make some helpful dict to map the data
imgdir = os.path.join(datapath, 'images')

#remap images to dict by id
imgdict = {l['id']:l for l in data['images']}
#read in all images, can take some time
for i in imgdict.values():
  i['image'] = io.imread(os.path.join(imgdir, i['file_name']))[:, :,: 3]  # drop alpha channel, if it's there

# remap annotations to dict by image_id
from collections import defaultdict
annodict = defaultdict(list)
for annotation in data['annotations']:
  annodict[annotation['image_id']].append(annotation)

# setup list of categories
categories = data['categories']
ncategories = len(categories)
cat_ids = [i['id'] for i in categories]
category_names = {7:'nut', 3:'wood screw', 2:'lag wood screw', 8:'bolt',
                  6:'black oxide screw', 5:'shiny screw', 4:'short wood screw',
                  1:'long lag screw', 9:'large nut', 11:'nut', 10:'nut',
                  12:'machine screw', 13:'short machine screw' }

"""# Image and Annotation Visualization with Bounding Box Extraction
This section displays an annotated image with bounding boxes around detected objects and creates individual subplots for each detected object's rotated subimage. The main image is displayed with bounding boxes applied to visually represent each annotated region, and smaller subimages show these regions in isolation.

1. Bounding Box Extraction: The extract_subimg_bbox function is defined to isolate and extract each bounding box region from the main image. Given bounding box parameters (center coordinates, height, width, and rotation angle), this function calculates the top-left and bottom-right corners of each bounding box and returns the cropped subimage.
2. Grid Setup: Using matplotlib.gridspec, a flexible grid layout is created. The first grid cell displays the main image, while subsequent cells are reserved for each annotated subimage, allowing each region to be visualized separately.
3. Bounding Box Visualization: For each annotation, a rectangular patch is added to the main image to represent the bounding box. Colors are dynamically assigned based on category IDs, using a colormap to differentiate categories visually. Each rectangle is rotated according to the bounding box's angle to match the object's orientation in the image.
4. Rotated Subimage Display: Each bounding box region is extracted, rotated, and displayed in its dedicated subplot. This approach provides a detailed view of each detected object, making it easier to analyze individual components.
A colorbar is also included to represent category labels, enhancing interpretability by allowing users to quickly identify each category within the annotated regions.

This visualization method is beneficial for object detection tasks, enabling easy inspection of detected objects and ensuring that bounding boxes are correctly aligned with each object's orientation in the image.







"""

import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
import matplotlib.gridspec as gridspec
import matplotlib.transforms as plt_transforms

# Assuming you have these variables initialized:
imageid = 100
im = imgdict[imageid]['image']
ncategories = 10  # Assuming you have a total of 10 categories
cmap_normal = plt.Normalize(0, ncategories)

# Define a function to extract the subimage based on bounding box coordinates
def extract_subimg_bbox(im, bbox):
    center_y, center_x, height, width, rotation_angle = bbox

    # Calculate the top-left and bottom-right corners of the bounding box
    y1 = center_y - height / 2
    y2 = center_y + height / 2
    x1 = center_x - width / 2
    x2 = center_x + width / 2

    # Return the extracted subimage
    return im[int(y1):int(y2), int(x1):int(x2)]

# Set up the grid for the image and annotations
gs = gridspec.GridSpec(1, 1 + len(annodict[imageid]),
                       width_ratios=[1,] + [0.1] * len(annodict[imageid]),
                       wspace=0.05)

plt.figure()

# Plot the main image
ax = plt.subplot(gs[0])
plt.imshow(im)

# Iterate over each annotation for the image
for i, annotation in enumerate(annodict[imageid]):
    bbox = annotation['bbox']  # bbox format: [center_y, center_x, height, width, rotation_angle]

    # Create a rectangle patch for the bounding box
    color = plt.cm.jet(cmap_normal(annotation['category_id']))
    rect = patches.Rectangle((bbox[1] - bbox[3] / 2, bbox[0] - bbox[2] / 2),
                             bbox[3], bbox[2],
                             linewidth=1, edgecolor=color, facecolor='none')

    # Apply rotation transform to the rectangle
    t = plt_transforms.Affine2D().rotate_around(bbox[1], bbox[0], -bbox[4] + np.pi / 2)
    rect.set_transform(t + plt.gca().transData)
    ax.add_patch(rect)

    # Extract and plot the rotated subimage for each annotation
    plt.subplot(gs[i + 1])
    rotated_im = extract_subimg_bbox(im, bbox)
    plt.imshow(rotated_im)
    plt.axis('off')
    plt.title(annotation['category_id'])

# Add colorbar for category labels
plt.colorbar(ticks=range(ncategories), label='category')
plt.clim(-0.5, ncategories - 0.5)

# Show the plot
plt.show()

"""# Creating a Dictionary of Subimages by Category
This code snippet organizes subimages by category, grouping each annotated region (subimage) according to its category ID.

1. Dictionary Setup: cat_imgdict is initialized to store lists of subimages, keyed by category ID.
2. Subimage Extraction: For each image, bounding boxes from annotations are used to extract subimages. Each extracted subimage is then stored in cat_imgdict under its respective category ID.

This structure enables efficient retrieval of all subimages for any given category, which is useful for tasks like category-specific analysis or visualization.
"""

# create a dict mapping category id to all subimages, can take some time to run
cat_imgdict = defaultdict(list)
for img_id, image in imgdict.items():
  for annotation in annodict[img_id]:
    bbox = annotation['bbox']
    subimg = extract_subimg_bbox(image['image'], bbox)
    cat_imgdict[annotation['category_id']].append(subimg.copy())

# How many images are in each category?
for k, v  in cat_imgdict.items():
  print(f"Category ID {k} has {len(v)} items")  #f-strings are neat - see https://realpython.com/python-f-strings/

"""# Displaying Example Subimages for Each Category
This section visualizes a set of example subimages for each category, enabling a quick overview of the detected objects in different categories.

1. Grid Layout: For each category, a grid layout is created using gridspec.GridSpec, with space for five example images per category.
2. Subimage Display: For each category ID in cat_imgdict, the first five subimages are displayed in individual grid cells. If a subimage lacks valid image data, a placeholder message (No image data) is shown instead.
3. Category Title: Each figure is titled with the category name and ID, making it easy to identify which category each set of examples belongs to.

This setup provides a quick and organized way to view representative samples for each category, which is especially useful for checking the consistency and accuracy of extracted annotations.
"""

import matplotlib.gridspec as gridspec
import matplotlib.pyplot as plt

# Plot some examples from each category
for catid, examples in cat_imgdict.items():
    num_examples = 5  # Define how many examples to show
    gs = gridspec.GridSpec(1, num_examples)
    plt.figure()

    # Loop over examples for each category
    for i, example in enumerate(examples[:num_examples]):
        plt.subplot(gs[i])

        # Check if the example has valid image data
        if example.size > 0:  # Ensure the image is not empty
            plt.imshow(example)
        else:
            plt.text(0.5, 0.5, 'No image data', ha='center', va='center')

    # Add a title for the category
    plt.suptitle(f"{category_names[catid]} {catid}")

plt.show()

"""# Extracting and Displaying Object and Blank Patches
This section of code creates image patches containing both annotated objects (nuts) and randomly selected blank patches, displaying them in a structured grid for easy comparison. This setup is useful for visualizing both positive samples (with objects) and negative samples (without objects), aiding in tasks such as training machine learning models for object detection.

1. Extracting Object Patches: For each image, bounding boxes of specific categories (in this case, nuts) are processed. The extract_subimg function crops a patch centered on the object. Only patches matching the predefined patch size are retained.
2. Extracting Blank Patches: Random locations within images are selected to create patches that do not contain any labeled objects. Using Polygon intersections from the shapely library, these locations are verified to ensure they dont overlap with any annotated bounding boxes. This results in a set of background patches that contain no target objects.
3. Patch Display: The extracted object and blank patches are displayed in a grid layout with matplotlib.gridspec, where the top row shows object patches, and the bottom row shows blank patches.
4. Labeling and Shuffling: Labels are assigned to the patches (1 for object patches and 0 for blank patches) and then randomly shuffled. This balanced dataset of object and background patches can be useful for training object recognition models.

By visualizing these patches, this setup helps confirm the quality of extracted regions, ensuring that object and blank patches are clearly distinguishable.
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import random
from shapely.geometry import Polygon

# Define the extract_subimg function
def extract_subimg(image, center, width, height, rotation_angle):
    # Assuming center is (center_y, center_x)
    center_y, center_x = center

    # Calculate the top-left and bottom-right corners
    y1 = int(center_y - height / 2)
    y2 = int(center_y + height / 2)
    x1 = int(center_x - width / 2)
    x2 = int(center_x + width / 2)

    # Extract the subimage
    subimg = image[y1:y2, x1:x2]

    # Return the extracted subimage
    return subimg

# Assuming these functions are defined elsewhere in your code
# unpack_bbox, rotcorners_from_coords

use_categories = [7, 10]
patch_size = np.array((128, 128))
num_patches_per_category = 500

nut_patches = []
for img_id, image in imgdict.items():
    for annotation in annodict[img_id]:
        if annotation['category_id'] in use_categories:
            bbox = annotation['bbox']
            rot_center, width, height, theta = unpack_bbox(bbox)

            # Extract subimage
            subimg = extract_subimg(image['image'], rot_center, patch_size[0], patch_size[1], 0)
            if all(subimg.shape[:2] == patch_size):
                nut_patches.append(subimg)

    if len(nut_patches) >= num_patches_per_category:
        break

# Select random blank patches
blank_patches = []
for i in range(len(nut_patches)):
    while True:  # until a suitable random patch is found
        # Choose random image
        imgid, imgobj = random.choice(list(imgdict.items()))
        im = imgobj['image']

        # Choose random place at least half a patch size from edges
        rand_center = np.random.randint((patch_size // 2), np.array(im.shape)[:2] - patch_size // 2)
        corners = rotcorners_from_coords(rand_center, patch_size[0], patch_size[1], 0)

        # Check if the random patch intersects with any labeled objects
        if not any([Polygon(corners).intersects(Polygon(rotcorners_from_coords(*unpack_bbox(annotation['bbox']))))
                    for annotation in annodict[imgid]]):
            rand_patch = im[rand_center[0] - patch_size[0] // 2:rand_center[0] + patch_size[0] // 2,
                            rand_center[1] - patch_size[1] // 2:rand_center[1] + patch_size[1] // 2]
            blank_patches.append(rand_patch)
            break

# Plot examples
num_examples = 10
plt.figure()
gs = gridspec.GridSpec(2, num_examples, wspace=0.05)
for i in range(num_examples):
    plt.subplot(gs[0, i])
    plt.imshow(nut_patches[i])
    plt.subplot(gs[1, i])
    plt.imshow(blank_patches[i])

# Label the patches
patch_labels = [1] * len(nut_patches) + [0] * len(blank_patches)
all_patches = nut_patches + blank_patches

# Randomly shuffle the patches and labels
shuffle_idx = np.random.choice(len(patch_labels), len(patch_labels), replace=False)
patch_labels = [patch_labels[i] for i in shuffle_idx]
all_patches = [all_patches[i] for i in shuffle_idx]

plt.show()

# Check shapes are correct
# assert all([p.shape == (128,128,3) for p in all_patches])
[i for i,p in enumerate(all_patches) if p.shape != (128, 128, 3)]

# Preprocess data
preprocess = transforms.Compose([
   transforms.ToTensor(),
   transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

train_frac = .2
train_number = int(len(all_patches)*train_frac)
# test_nuumber = all_patches.len()-train_number
train_patches, train_labels = all_patches[:train_number], patch_labels[:train_number]
test_patches, test_labels = all_patches[train_number:], patch_labels[train_number:]

plt.figure()
plt.imshow(preprocess(all_patches[0]).permute(1, 2, 0))
plt.show()

class SimpleScrewNet(nn.Module):
  def __init__(self):
    super().__init__()

    LeakyReLU = nn.LeakyReLU()
    MaxPool2d = nn.MaxPool2d(2, stride=2)
    self.layers = nn.Sequential(
        nn.Conv2d(3, 16, kernel_size=7, stride=2),
        LeakyReLU,
        MaxPool2d,

        nn.Conv2d(16, 32, kernel_size=5),
        # nn.Conv2d(32, 32, kernel_size=5),
        LeakyReLU,
        MaxPool2d,

        nn.Conv2d(32, 64, kernel_size=5),
        LeakyReLU,
        MaxPool2d,

        nn.Flatten(1),

        nn.Linear(1024, 64),
        # nn.Dropout(),
        nn.Linear(64, 2),

        # nn.Conv2d(3, 6, 5),
        # nn.MaxPool2d(2, 2),
        # nn.Conv2d(6, 16, 5),
        # nn.Linear(16 * 5 * 5, 120),
        # nn.Linear(120, 84),
        # nn.Linear(84, 2),

    )

  def forward(self, x):
    # Simply pass the data through the layers
    return self.layers(x)

# Inspect model structure and layer sizes
snet = SimpleScrewNet().to(device)
summary(snet, input_size=(3, 128, 128))

# Loss
loss_fn=nn.CrossEntropyLoss()
optimizer=optim.SGD(snet.parameters(),lr=0.000001,momentum=0.3)

"""# Training and Evaluation Loop for Image Classification Model
This code snippet sets up a training and evaluation loop for an image classification model using PyTorch, which iteratively trains the model on labeled image patches and evaluates its performance on a test set.

1. Device Selection: The code checks for a GPU (CUDA) and assigns it as the processing device if available, otherwise defaults to CPU.
Initial Test Accuracy: Before training, the initial accuracy on the test set is computed. Each test image is fed into the model, and the percentage of correct predictions is printed to establish a baseline.
2. Training Loop:
     *  Epochs: The model is trained over a specified number of epochs (num_epoch), where each epoch consists of forward and backward passes on the training data.
     * Training Phase: For each image-label pair in train_patches and train_labels, the image is converted to a tensor, adjusted for channel ordering, and moved to the device. The models prediction is computed, and a loss function calculates the error. The gradient of this loss is backpropagated, updating the model parameters to minimize error.
     * Evaluation Phase: After each epoch, the model is evaluated on the test data using torch.no_grad() to disable gradient computation, reducing memory usage and speeding up the evaluation. The test loss and accuracy (percentage of correct predictions) are recorded for tracking.
3. Metrics Logging: After each epoch, the following metrics are stored and printed:
     * Train Loss: The cumulative training loss, providing a measure of how well the model is learning from the training data.
     * Test Loss: The cumulative test loss, indicating how well the model generalizes to unseen data.
     * Test Accuracy: The percentage of correct predictions on the test set.

This setup enables monitoring of the models performance across epochs, providing insights into its learning progress and generalization ability. By tracking these metrics, you can determine if further tuning or adjustments to the training process are needed to improve model accuracy.







"""

import torch
import numpy as np

# Check if CUDA is available
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Train
num_epoch = 5
train_losses = []  # loss per epoch
test_losses = []  # loss per epoch
test_corrects = []  # % correct per epoch

test_correct = []
with torch.no_grad():
    for img, lbl in zip(test_patches, test_labels):
        img = torch.from_numpy(img).float().permute(2, 1, 0).unsqueeze(0).to(device)
        lbl = torch.tensor(lbl).unsqueeze(0).to(device)
        predict = snet(img)
        test_correct.append((predict.argmax() == lbl).item())
test_correct = np.array(test_correct)
print(f'Before starting: {test_correct.mean()*100:.2f}% of test images correct')

for epoch in range(num_epoch):
    train_loss = 0.0
    test_loss = 0.0
    test_correct = []

    snet.train()
    for img, lbl in zip(train_patches, train_labels):
        img = torch.from_numpy(img).float().permute(2, 1, 0).unsqueeze(0).to(device)
        lbl = torch.tensor(lbl).unsqueeze(0).to(device)

        optimizer.zero_grad()
        predict = snet(img)
        loss = loss_fn(predict, lbl)
        loss.backward()
        optimizer.step()
        train_loss += loss.item() * img.size(0)

    with torch.no_grad():
        for img, lbl in zip(test_patches, test_labels):
            img = torch.from_numpy(img).float().permute(2, 1, 0).unsqueeze(0).to(device)
            lbl = torch.tensor(lbl).unsqueeze(0).to(device)
            predict = snet(img)
            loss = loss_fn(predict, lbl)
            test_loss += loss.item() * img.size(0)
            test_correct.append((predict.argmax() == lbl).item())

    test_correct = np.array(test_correct).mean()
    train_losses.append(train_loss)
    test_losses.append(test_loss)
    test_corrects.append(test_correct)
    print(f'Epoch: {epoch} Train Loss: {train_loss:.3f} Test Loss: {test_loss:.3f} Percent correct: {test_correct*100:.2f}%')

"""# Calculating Test Accuracy
This code snippet evaluates the model's accuracy on the test set by calculating the percentage of correct predictions.

1. Prediction and Comparison: For each test image, the models prediction is generated and compared to the true label.
2. Accuracy Calculation: The correct list stores whether each prediction is correct, and the mean of this list represents the overall accuracy.

The final output prints the percentage of correctly classified test images, providing a quick assessment of model performance on the test data.
"""

# calculate percentage correct
correct = []
with torch.no_grad():
  for img,lbl in zip(test_patches, test_labels):
    img=torch.from_numpy(img).float().permute(2,1,0).unsqueeze(0).to(device)
    lbl=torch.torch.as_tensor(lbl).unsqueeze(0).to(device)
    predict=snet(img)
    correct += [(predict.argmax() == lbl).item()]
correct = np.array(correct)
print(f'{correct.mean():.3f}% of test images correct')

plt.figure()
plt.plot(train_losses, label='train')
plt.plot(test_losses, label='test')
plt.legend()
plt.xlabel('Epoch')
plt.ylabel('Loss')

"""# Visualizing Images with Annotations
The visualize_labels function displays a set of images from the dataset along with their associated labels, making it easy to inspect both the images and their annotated categories.

1. Parameters:

     * imgdict: Dictionary containing image data.
     * annodict: Dictionary mapping image IDs to annotations.
     * category_names: Dictionary mapping category IDs to readable labels.
     * num_images: Number of images to display.
2. Function Workflow:

     * Image Display: For each image (up to num_images), the function retrieves and displays the image without axis markings for a cleaner look.
     * Annotation Labels: After displaying the image, the function prints each annotation associated with that image. Each annotation includes the category ID and a human-readable label from category_names. If no annotations are available, the function indicates that as well.

This function provides an easy way to review images and their annotated labels, useful for verifying the correctness of annotations in the dataset.
"""

import matplotlib.pyplot as plt

# Assuming you have the following variables from your dataset:
# - imgdict: dictionary of images
# - annodict: dictionary of annotations (bounding boxes, labels, etc.)
# - category_names: a dictionary that maps category_id to a human-readable name

# For this program, we will loop over a subset of images and their labels

def visualize_labels(imgdict, annodict, category_names, num_images=5):
    """
    Visualizes images from the dataset and prints out their associated labels.
    :param imgdict: Dictionary with image data
    :param annodict: Dictionary with annotations
    :param category_names: Dictionary mapping category_id to human-readable label
    :param num_images: Number of images to display
    """
    for img_id, image_data in list(imgdict.items())[:num_images]:
        # Get the image (assuming it's stored under 'image' key in imgdict)
        image = image_data['image']

        # Get the annotations for this image
        annotations = annodict.get(img_id, [])

        # Display the image
        plt.imshow(image)
        plt.axis('off')  # Hide the axes for better visualization
        plt.show()

        # Print the annotations (category names or IDs)
        if annotations:
            print(f"Image ID: {img_id}")
            for annotation in annotations:
                category_id = annotation['category_id']
                label_name = category_names.get(category_id, f"Unknown (ID {category_id})")
                print(f"  - Category ID: {category_id}, Label: {label_name}")
        else:
            print(f"Image ID: {img_id} has no annotations")

# Example usage:
# Assuming you have 'category_names' defined elsewhere in your code
# Replace imgdict, annodict, and category_names with your actual data
visualize_labels(imgdict, annodict, category_names, num_images=10)

# Dictionary that maps category IDs to detailed information
category_info = {
    1: {"name": "Long Lag Screw", "type": "Screw", "material": "Steel", "size": "M10", "description": "A long lag screw used in heavy wood fastening."},
    2: {"name": "Lag Wood Screw", "type": "Screw", "material": "Brass", "size": "M8", "description": "Wood screw for structural work."},
    3: {"name": "Wood Screw", "type": "Screw", "material": "Stainless Steel", "size": "M6", "description": "Basic wood screw."},
    4: {"name": "Short Wood Screw", "type": "Screw", "material": "Steel", "size": "M4", "description": "Short wood screw for small projects."},
    5: {"name": "Shiny Screw", "type": "Screw", "material": "Chrome Plated", "size": "M5", "description": "Screw with shiny finish."},
    6: {"name": "Black Oxide Screw", "type": "Screw", "material": "Black Oxide Steel", "size": "M5", "description": "Screw with black oxide coating."},
    7: {"name": "Nut", "type": "Nut", "material": "Steel", "size": "M10", "description": "Nut for securing bolts."},
    8: {"name": "Bolt", "type": "Bolt", "material": "Steel", "size": "M10", "description": "A heavy-duty bolt for fastening."}
    # You can add more details as needed
}

"""# Screw Image Analysis and Identification System
This program allows users to upload an image of a screw, bolt, or nut and performs automatic classification and feature detection using OpenCV. The detected item's information, including material, head type, and typical applications, is displayed to the user. This tool is especially useful for those in manufacturing, construction, or repair, who need to quickly identify hardware types and their specifications.

# Key Components
1. Detailed Category Information: The program includes an extensive dictionary, category_info, which stores detailed metadata for each screw type. For each type, details such as material, size, head type, drive type, thread type, strength grade, coating, application, and a description are included. This allows the program to provide a comprehensive report about each identified screw, aiding users in understanding the suitability of the screw for various tasks and environments.

2. Image Analysis with OpenCV: The analyze_screw_image function is designed to classify screws based on their visual features using edge detection:

     * Edge Detection: The image is converted to grayscale, and edges are detected using Canny edge detection, which highlights the contours of the screw.
     * Contour Analysis: The program counts the contours (edges) within the image. Based on the number of contours, it makes a simplified classification:
        * High contour count (e.g., star shapes) may indicate a Torx screw.
        * Moderate contour count could represent a Phillips or Flat Head screw.
        * Low contour count generally identifies simpler shapes, like a Long Lag Screw.

This basic contour-based classification is used to assign a category ID, which links to the category_info dictionary for detailed information.

# User-Friendly File Upload and Analysis:

1. File Upload: The program provides a widget for users to upload an image file. The uploaded image is then processed to determine the screw type.
2. Display and Annotation: The uploaded image is displayed without axes for a clear view. The program fetches and prints detailed information about the detected screw, including material, coating, application, and more.
3. Detailed Output: For each detected screw, the program prints the following information:

       * Name, type, material, size, head type, drive type, thread type, strength grade, coating, application, and a detailed description.
      * If a screw type is unknown or unrecognized, it defaults to "Unknown" with no description.
# How to Use
1. Upload an Image: Use the provided upload widget to select an image of a screw.
2. View the Analysis: Once uploaded, the image is analyzed, and the detected screw type information is displayed, including relevant specifications and applications.
"""

import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
from io import BytesIO
from IPython.display import display
import ipywidgets as widgets

# Enhanced category information with additional details
category_info = {
    1: {
        "name": "Long Lag Screw",
        "type": "Screw",
        "material": "Steel",
        "size": "M10",
        "head_type": "Hex Head",
        "drive_type": "Wrench Drive",
        "thread_type": "Coarse",
        "strength_grade": "Grade 5",
        "coating": "Zinc Plated",
        "application": "Heavy wood fastening, often used in construction.",
        "description": (
            "A long, zinc-plated steel lag screw designed for heavy-duty wood fastening applications in construction. "
            "The coarse thread offers strong holding power in wood, ideal for securing beams and large structures such "
            "as decks and fences. Its hex head allows for high torque using a wrench drive, ensuring reliable structural "
            "support in high-load applications. This screw is especially suited for outdoor use due to its corrosion-resistant coating."
        )
    },
    2: {
        "name": "Lag Wood Screw",
        "type": "Screw",
        "material": "Brass",
        "size": "M8",
        "head_type": "Hex Head",
        "drive_type": "Wrench Drive",
        "thread_type": "Coarse",
        "strength_grade": "Grade 2",
        "coating": "Brass Finish",
        "application": "Structural wood fastening.",
        "description": (
            "A brass-finished lag screw with a hex head, ideal for wood structural applications where an aesthetic finish is important. "
            "The coarse thread provides a solid hold in wood, making it suitable for interior woodworking projects that require strength "
            "and decorative appeal. Commonly used in cabinetry, interior wood joinery, and wooden furniture assembly where corrosion "
            "resistance and an elegant look are essential."
        )
    },
    3: {
        "name": "Wood Screw",
        "type": "Screw",
        "material": "Stainless Steel",
        "size": "M6",
        "head_type": "Flat Head",
        "drive_type": "Phillips Drive",
        "thread_type": "Sharp Point",
        "strength_grade": "Grade 4.8",
        "coating": "Uncoated (Stainless Steel)",
        "application": "General wood fastening.",
        "description": (
            "A versatile stainless steel wood screw with a sharp-point thread and flat head, allowing it to sit flush with surfaces for a smooth finish. "
            "This Phillips-drive screw is designed for general wood fastening tasks, providing excellent corrosion resistance for both indoor and outdoor "
            "projects. Commonly used in furniture assembly, cabinetry, and small construction tasks, this screw is highly resistant to rust, making it "
            "ideal for use in moisture-prone environments."
        )
    },
    4: {
        "name": "Short Wood Screw",
        "type": "Screw",
        "material": "Steel",
        "size": "M4",
        "head_type": "Flat Head",
        "drive_type": "Phillips Drive",
        "thread_type": "Sharp Point",
        "strength_grade": "Grade 2",
        "coating": "Nickel Plated",
        "application": "Small wood projects or furniture assembly.",
        "description": (
            "A short, nickel-plated steel screw with a flat head and Phillips drive, suitable for light-duty applications such as assembling furniture and "
            "joining smaller pieces of wood. The nickel plating provides moderate corrosion resistance, while the sharp point and coarse threading allow "
            "it to easily penetrate wood, making it a popular choice for interior projects requiring a polished appearance."
        )
    },
    5: {
        "name": "Shiny Screw",
        "type": "Screw",
        "material": "Chrome Plated",
        "size": "M5",
        "head_type": "Round Head",
        "drive_type": "Phillips Drive",
        "thread_type": "Sharp Point",
        "strength_grade": "Grade 4.8",
        "coating": "Chrome Plated",
        "application": "Decorative projects requiring shiny finishes.",
        "description": (
            "This chrome-plated screw with a round head is designed for decorative applications requiring an appealing, shiny finish. "
            "Ideal for interior fixtures and trim work, this screw offers moderate strength and corrosion resistance due to its chrome plating. "
            "Its round head provides an attractive appearance, making it a preferred choice in automotive interiors, home decor, and other "
            "projects where visual appeal is essential."
        )
    },
    6: {
        "name": "Black Oxide Screw",
        "type": "Screw",
        "material": "Black Oxide Steel",
        "size": "M5",
        "head_type": "Pan Head",
        "drive_type": "Torx Drive",
        "thread_type": "Machine Thread",
        "strength_grade": "Grade 8.8",
        "coating": "Black Oxide",
        "application": "Industrial and automotive assembly.",
        "description": (
            "A high-strength, black oxide-coated screw with a pan head and Torx drive, suitable for industrial and automotive applications. "
            "The black oxide finish provides a sleek look while offering corrosion resistance, and the Torx drive prevents cam-out, allowing "
            "for high torque application without stripping. Ideal for machine assembly, automotive parts, and other high-stress environments "
            "where a secure and durable connection is required."
        )
    },
    7: {
        "name": "Nut",
        "type": "Nut",
        "material": "Steel",
        "size": "M10",
        "head_type": "Hexagonal",
        "drive_type": "Wrench",
        "thread_type": "Coarse",
        "strength_grade": "Grade 8",
        "coating": "Galvanized",
        "application": "Securing bolts in heavy machinery or structural work.",
        "description": (
            "A steel hexagonal nut, often galvanized for corrosion resistance, used to securely fasten bolts in machinery and structural applications. "
            "With a high strength grade, this nut is ideal for heavy-duty environments where strong and reliable fastening is crucial, such as in "
            "construction, automotive, and heavy equipment."
        )
    },
    8: {
        "name": "Bolt",
        "type": "Bolt",
        "material": "Steel",
        "size": "M10",
        "head_type": "Hex Head",
        "drive_type": "Wrench Drive",
        "thread_type": "Coarse",
        "strength_grade": "Grade 8",
        "coating": "Galvanized",
        "application": "Heavy-duty fastening in mechanical and construction projects.",
        "description": (
            "A heavy-duty hex head bolt made of high-strength steel, commonly galvanized to prevent rust. Its hex head allows for high torque "
            "application, making it suitable for demanding structural applications in construction, machinery, and automotive repair. Paired "
            "with nuts and washers, it provides a secure connection in metal, wood, or concrete."
        )
    },
    9: {
        "name": "Torx Screw",
        "type": "Screw",
        "material": "Stainless Steel",
        "size": "M4",
        "head_type": "Flat Head",
        "drive_type": "Torx Drive",
        "thread_type": "Sharp Point",
        "strength_grade": "Grade 5",
        "coating": "Uncoated (Stainless Steel)",
        "application": "Electronics assembly and tamper-resistant applications.",
        "description": (
            "A stainless steel Torx screw with a flat head, designed for applications that require tamper resistance, such as electronics assembly "
            "and automotive components. Its Torx drive minimizes stripping and allows for precise torque application, while the stainless steel "
            "composition offers excellent corrosion resistance, making it suitable for both indoor and outdoor use."
        )
    },
    10: {
        "name": "Phillips Screw",
        "type": "Screw",
        "material": "Zinc Coated Steel",
        "size": "M3",
        "head_type": "Flat Head",
        "drive_type": "Phillips Drive",
        "thread_type": "Fine Thread",
        "strength_grade": "Grade 2",
        "coating": "Zinc Coated",
        "application": "General fastening in home projects and furniture.",
        "description": (
            "A versatile Phillips screw with a flat head and zinc coating, ideal for general-purpose home improvement and furniture assembly. "
            "Its flat head allows it to sit flush with surfaces, and the zinc coating provides basic corrosion resistance, making it suitable "
            "for light-duty indoor projects, including attaching brackets, fixtures, and assembling cabinets."
        )
    },
    11: {
        "name": "Hex Socket Cap Screw",
        "type": "Screw",
        "material": "Alloy Steel",
        "size": "M6",
        "head_type": "Socket Head",
        "drive_type": "Hex Allen Key Drive",
        "thread_type": "Fine Thread",
        "strength_grade": "Grade 12.9",
        "coating": "Uncoated (Alloy Steel)",
        "application": "High-strength fastening in machinery.",
        "description": (
            "An alloy steel hex socket cap screw designed for applications requiring high tensile strength, such as machinery and mechanical assemblies. "
            "Its socket head allows for precise torque application with an Allen key, and its alloy steel construction offers exceptional strength and "
            "durability, making it ideal for high-vibration environments."
        )
    },
    12: {
        "name": "Flat Head Machine Screw",
        "type": "Screw",
        "material": "Nickel Coated Steel",
        "size": "M3",
        "head_type": "Flat Head",
        "drive_type": "Phillips Drive",
        "thread_type": "Machine Thread",
        "strength_grade": "Grade 4.8",
        "coating": "Nickel Coated",
        "application": "Machinery assembly and general purpose.",
        "description": (
            "A flat head machine screw with nickel coating, suitable for a variety of machinery and general-purpose applications. Its machine thread "
            "allows it to fasten metal components tightly, while the nickel coating provides corrosion resistance, making it suitable for electronics, "
            "machinery, and household applications."
        )
    },
    13: {
        "name": "Pan Head Sheet Metal Screw",
        "type": "Screw",
        "material": "Stainless Steel",
        "size": "M4",
        "head_type": "Pan Head",
        "drive_type": "Phillips Drive",
        "thread_type": "Sharp Point",
        "strength_grade": "Grade 4.8",
        "coating": "Uncoated (Stainless Steel)",
        "application": "Sheet metal fastening.",
        "description": (
            "A stainless steel pan head sheet metal screw with a Phillips drive, commonly used for fastening thin metal materials in construction and "
            "automotive applications. Its pan head provides strong surface contact, while its sharp point allows easy penetration without pre-drilling."
        )
    },
    14: {
        "name": "Self-Tapping Screw",
        "type": "Screw",
        "material": "Hardened Steel",
        "size": "M5",
        "head_type": "Flat Head",
        "drive_type": "Phillips Drive",
        "thread_type": "Self-Tapping",
        "strength_grade": "Grade 5",
        "coating": "Uncoated (Hardened Steel)",
        "application": "Metal and plastic fastening without pre-drilling.",
        "description": (
            "A self-tapping screw made from hardened steel, designed to drill its own threads in thin metal or plastic. Ideal for construction, "
            "automotive, and household repair, this screw eliminates the need for pre-drilling, making it a time-efficient choice for quick installations."
        )
    }
}



# Function to analyze an image using basic feature detection (OpenCV)
def analyze_screw_image(image):
    """
    Basic feature extraction using OpenCV (edge detection) to detect head and drive type.
    """
    # Convert the PIL image to OpenCV format
    img_cv = np.array(image)
    gray = cv2.cvtColor(img_cv, cv2.COLOR_RGB2GRAY)

    # Use Canny edge detection to find edges
    edges = cv2.Canny(gray, threshold1=50, threshold2=150)

    # Detect contours in the image (these may correspond to head type or drive type)
    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Analyze contours to classify head or drive type
    # For simplicity, we count the number of contours (e.g., star shape for Torx)
    contour_count = len(contours)

    # Example classification based on number of contours (simplified)
    if contour_count > 50:  # High contour count may correspond to complex shapes like Torx
        return 9  # Torx Screw
    elif contour_count > 20:  # Moderate contour count could correspond to Phillips or Flat Head
        return 10  # Phillips Screw
    else:
        return 1  # Default to Long Lag Screw for simpler shapes

# Function to handle file upload and analysis
def on_upload_change(change):
    """
    Callback function when file upload widget receives an image.
    """
    # Get the uploaded file
    uploaded_file = list(change['new'].values())[0]

    # Convert the file content (binary) to an image using BytesIO
    img = Image.open(BytesIO(uploaded_file['content']))

    # Display the image
    plt.imshow(img)
    plt.axis('off')  # Hide the axes for better visualization
    plt.show()

    # Analyze the image using feature detection
    category_id = analyze_screw_image(img)

    # Fetch the detailed information based on category ID
    info = category_info.get(category_id, {"name": "Unknown", "type": "Unknown", "description": "No description available."})

    # Display the information
    print(f"Detected Screw Information:")
    print(f"  - Name: {info['name']}")
    print(f"  - Type: {info['type']}")
    print(f"  - Material: {info.get('material', 'Unknown')}")
    print(f"  - Size: {info.get('size', 'Unknown')}")
    print(f"  - Head Type: {info.get('head_type', 'Unknown')}")
    print(f"  - Drive Type: {info.get('drive_type', 'Unknown')}")
    print(f"  - Thread Type: {info.get('thread_type', 'Unknown')}")
    print(f"  - Strength Grade: {info.get('strength_grade', 'Unknown')}")
    print(f"  - Coating: {info.get('coating', 'Unknown')}")
    print(f"  - Application: {info.get('application', 'Unknown')}")
    print(f"  - Description: {info['description']}")

# Create an upload widget
upload_widget = widgets.FileUpload(accept='image/*', multiple=False)

# Bind the callback function to the upload widget
upload_widget.observe(on_upload_change, names='value')

# Display the upload widget
display(upload_widget)

"""# Program for video analysis of screw
This code is designed to analyze screws from  videos uploaded through a user-friendly widget in a Jupyter Notebook.
"""

import cv2
import numpy as np
from PIL import Image
from io import BytesIO
from ipywidgets import FileUpload
from IPython.display import display

# Screw category information
category_info = {
    1: {"name": "Long Lag Screw", "type": "Screw", "description": "A long screw designed for heavy wood fastening."},
    9: {"name": "Torx Screw", "type": "Screw", "description": "A screw with a Torx head, commonly used in electronics."},
    10: {"name": "Phillips Screw", "type": "Screw", "description": "A versatile screw with a Phillips head."},
}

def analyze_video(video_bytes):
    """
    Process a video uploaded as bytes to classify the screw based on frame analysis.
    """
    # Save the video to a temporary file
    temp_video_path = "/tmp/uploaded_video.mp4"
    with open(temp_video_path, "wb") as temp_video:
        temp_video.write(video_bytes)

    cap = cv2.VideoCapture(temp_video_path)
    frame_interval = 10  # Analyze every 10th frame
    frame_count = 0
    predictions = []

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        # Process every 10th frame
        if frame_count % frame_interval == 0:
            # Convert frame to PIL Image for compatibility with `analyze_screw_image`
            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            frame_image = Image.fromarray(frame_rgb)

            # Analyze the frame
            prediction = analyze_screw_image(frame_image)
            predictions.append(prediction)

        frame_count += 1

    cap.release()

    # Aggregate predictions using majority voting
    if predictions:
        final_prediction = max(set(predictions), key=predictions.count)
        return final_prediction
    else:
        return None  # No frames were analyzed

def analyze_screw_image(image):
    """
    Basic feature extraction using OpenCV (edge detection) to detect head and drive type.
    """
    img_cv = np.array(image)
    gray = cv2.cvtColor(img_cv, cv2.COLOR_RGB2GRAY)
    edges = cv2.Canny(gray, threshold1=50, threshold2=150)
    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    contour_count = len(contours)

    # Simplified classification logic
    if contour_count > 50:
        return 9  # Torx Screw
    elif contour_count > 20:
        return 10  # Phillips Screw
    else:
        return 1  # Long Lag Screw

def on_video_upload(change):
    """
    Callback function to handle video upload and analysis.
    """
    uploaded_video = list(change['new'].values())[0]
    video_bytes = uploaded_video['content']

    # Analyze the video
    category_id = analyze_video(video_bytes)

    # Fetch the detailed information based on category ID
    info = category_info.get(category_id, {"name": "Unknown", "type": "Unknown", "description": "No description available."})

    # Display the information
    print(f"Detected Screw Information from Video:")
    print(f"  - Name: {info['name']}")
    print(f"  - Type: {info['type']}")
    print(f"  - Description: {info['description']}")

# Create a video upload widget
upload_widget = FileUpload(accept='video/*', multiple=False)

# Bind the callback function to the upload widget
upload_widget.observe(on_video_upload, names='value')

# Display the upload widget
print("Please upload a video for analysis:")
display(upload_widget)

"""# Video and images analysis
This code is designed to analyze screws from either images or videos uploaded through a user-friendly widget in a Jupyter Notebook.
"""

import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
from io import BytesIO
from IPython.display import display
import ipywidgets as widgets

# Enhanced category information with additional details
category_info = {
    1: {
        "name": "Long Lag Screw",
        "type": "Screw",
        "material": "Steel",
        "size": "M10",
        "head_type": "Hex Head",
        "drive_type": "Wrench Drive",
        "thread_type": "Coarse",
        "strength_grade": "Grade 5",
        "coating": "Zinc Plated",
        "application": "Heavy wood fastening, often used in construction.",
        "description": (
            "A long, zinc-plated steel lag screw designed for heavy-duty wood fastening applications in construction. "
            "The coarse thread offers strong holding power in wood, ideal for securing beams and large structures such "
            "as decks and fences. Its hex head allows for high torque using a wrench drive, ensuring reliable structural "
            "support in high-load applications. This screw is especially suited for outdoor use due to its corrosion-resistant coating."
        )
    },
    2: {
        "name": "Lag Wood Screw",
        "type": "Screw",
        "material": "Brass",
        "size": "M8",
        "head_type": "Hex Head",
        "drive_type": "Wrench Drive",
        "thread_type": "Coarse",
        "strength_grade": "Grade 2",
        "coating": "Brass Finish",
        "application": "Structural wood fastening.",
        "description": (
            "A brass-finished lag screw with a hex head, ideal for wood structural applications where an aesthetic finish is important. "
            "The coarse thread provides a solid hold in wood, making it suitable for interior woodworking projects that require strength "
            "and decorative appeal. Commonly used in cabinetry, interior wood joinery, and wooden furniture assembly where corrosion "
            "resistance and an elegant look are essential."
        )
    },
    3: {
        "name": "Wood Screw",
        "type": "Screw",
        "material": "Stainless Steel",
        "size": "M6",
        "head_type": "Flat Head",
        "drive_type": "Phillips Drive",
        "thread_type": "Sharp Point",
        "strength_grade": "Grade 4.8",
        "coating": "Uncoated (Stainless Steel)",
        "application": "General wood fastening.",
        "description": (
            "A versatile stainless steel wood screw with a sharp-point thread and flat head, allowing it to sit flush with surfaces for a smooth finish. "
            "This Phillips-drive screw is designed for general wood fastening tasks, providing excellent corrosion resistance for both indoor and outdoor "
            "projects. Commonly used in furniture assembly, cabinetry, and small construction tasks, this screw is highly resistant to rust, making it "
            "ideal for use in moisture-prone environments."
        )
    },
    4: {
        "name": "Short Wood Screw",
        "type": "Screw",
        "material": "Steel",
        "size": "M4",
        "head_type": "Flat Head",
        "drive_type": "Phillips Drive",
        "thread_type": "Sharp Point",
        "strength_grade": "Grade 2",
        "coating": "Nickel Plated",
        "application": "Small wood projects or furniture assembly.",
        "description": (
            "A short, nickel-plated steel screw with a flat head and Phillips drive, suitable for light-duty applications such as assembling furniture and "
            "joining smaller pieces of wood. The nickel plating provides moderate corrosion resistance, while the sharp point and coarse threading allow "
            "it to easily penetrate wood, making it a popular choice for interior projects requiring a polished appearance."
        )
    },
    5: {
        "name": "Shiny Screw",
        "type": "Screw",
        "material": "Chrome Plated",
        "size": "M5",
        "head_type": "Round Head",
        "drive_type": "Phillips Drive",
        "thread_type": "Sharp Point",
        "strength_grade": "Grade 4.8",
        "coating": "Chrome Plated",
        "application": "Decorative projects requiring shiny finishes.",
        "description": (
            "This chrome-plated screw with a round head is designed for decorative applications requiring an appealing, shiny finish. "
            "Ideal for interior fixtures and trim work, this screw offers moderate strength and corrosion resistance due to its chrome plating. "
            "Its round head provides an attractive appearance, making it a preferred choice in automotive interiors, home decor, and other "
            "projects where visual appeal is essential."
        )
    },
    6: {
        "name": "Black Oxide Screw",
        "type": "Screw",
        "material": "Black Oxide Steel",
        "size": "M5",
        "head_type": "Pan Head",
        "drive_type": "Torx Drive",
        "thread_type": "Machine Thread",
        "strength_grade": "Grade 8.8",
        "coating": "Black Oxide",
        "application": "Industrial and automotive assembly.",
        "description": (
            "A high-strength, black oxide-coated screw with a pan head and Torx drive, suitable for industrial and automotive applications. "
            "The black oxide finish provides a sleek look while offering corrosion resistance, and the Torx drive prevents cam-out, allowing "
            "for high torque application without stripping. Ideal for machine assembly, automotive parts, and other high-stress environments "
            "where a secure and durable connection is required."
        )
    },
    7: {
        "name": "Nut",
        "type": "Nut",
        "material": "Steel",
        "size": "M10",
        "head_type": "Hexagonal",
        "drive_type": "Wrench",
        "thread_type": "Coarse",
        "strength_grade": "Grade 8",
        "coating": "Galvanized",
        "application": "Securing bolts in heavy machinery or structural work.",
        "description": (
            "A steel hexagonal nut, often galvanized for corrosion resistance, used to securely fasten bolts in machinery and structural applications. "
            "With a high strength grade, this nut is ideal for heavy-duty environments where strong and reliable fastening is crucial, such as in "
            "construction, automotive, and heavy equipment."
        )
    },
    8: {
        "name": "Bolt",
        "type": "Bolt",
        "material": "Steel",
        "size": "M10",
        "head_type": "Hex Head",
        "drive_type": "Wrench Drive",
        "thread_type": "Coarse",
        "strength_grade": "Grade 8",
        "coating": "Galvanized",
        "application": "Heavy-duty fastening in mechanical and construction projects.",
        "description": (
            "A heavy-duty hex head bolt made of high-strength steel, commonly galvanized to prevent rust. Its hex head allows for high torque "
            "application, making it suitable for demanding structural applications in construction, machinery, and automotive repair. Paired "
            "with nuts and washers, it provides a secure connection in metal, wood, or concrete."
        )
    },
    9: {
        "name": "Torx Screw",
        "type": "Screw",
        "material": "Stainless Steel",
        "size": "M4",
        "head_type": "Flat Head",
        "drive_type": "Torx Drive",
        "thread_type": "Sharp Point",
        "strength_grade": "Grade 5",
        "coating": "Uncoated (Stainless Steel)",
        "application": "Electronics assembly and tamper-resistant applications.",
        "description": (
            "A stainless steel Torx screw with a flat head, designed for applications that require tamper resistance, such as electronics assembly "
            "and automotive components. Its Torx drive minimizes stripping and allows for precise torque application, while the stainless steel "
            "composition offers excellent corrosion resistance, making it suitable for both indoor and outdoor use."
        )
    },
    10: {
        "name": "Phillips Screw",
        "type": "Screw",
        "material": "Zinc Coated Steel",
        "size": "M3",
        "head_type": "Flat Head",
        "drive_type": "Phillips Drive",
        "thread_type": "Fine Thread",
        "strength_grade": "Grade 2",
        "coating": "Zinc Coated",
        "application": "General fastening in home projects and furniture.",
        "description": (
            "A versatile Phillips screw with a flat head and zinc coating, ideal for general-purpose home improvement and furniture assembly. "
            "Its flat head allows it to sit flush with surfaces, and the zinc coating provides basic corrosion resistance, making it suitable "
            "for light-duty indoor projects, including attaching brackets, fixtures, and assembling cabinets."
        )
    },
    11: {
        "name": "Hex Socket Cap Screw",
        "type": "Screw",
        "material": "Alloy Steel",
        "size": "M6",
        "head_type": "Socket Head",
        "drive_type": "Hex Allen Key Drive",
        "thread_type": "Fine Thread",
        "strength_grade": "Grade 12.9",
        "coating": "Uncoated (Alloy Steel)",
        "application": "High-strength fastening in machinery.",
        "description": (
            "An alloy steel hex socket cap screw designed for applications requiring high tensile strength, such as machinery and mechanical assemblies. "
            "Its socket head allows for precise torque application with an Allen key, and its alloy steel construction offers exceptional strength and "
            "durability, making it ideal for high-vibration environments."
        )
    },
    12: {
        "name": "Flat Head Machine Screw",
        "type": "Screw",
        "material": "Nickel Coated Steel",
        "size": "M3",
        "head_type": "Flat Head",
        "drive_type": "Phillips Drive",
        "thread_type": "Machine Thread",
        "strength_grade": "Grade 4.8",
        "coating": "Nickel Coated",
        "application": "Machinery assembly and general purpose.",
        "description": (
            "A flat head machine screw with nickel coating, suitable for a variety of machinery and general-purpose applications. Its machine thread "
            "allows it to fasten metal components tightly, while the nickel coating provides corrosion resistance, making it suitable for electronics, "
            "machinery, and household applications."
        )
    },
    13: {
        "name": "Pan Head Sheet Metal Screw",
        "type": "Screw",
        "material": "Stainless Steel",
        "size": "M4",
        "head_type": "Pan Head",
        "drive_type": "Phillips Drive",
        "thread_type": "Sharp Point",
        "strength_grade": "Grade 4.8",
        "coating": "Uncoated (Stainless Steel)",
        "application": "Sheet metal fastening.",
        "description": (
            "A stainless steel pan head sheet metal screw with a Phillips drive, commonly used for fastening thin metal materials in construction and "
            "automotive applications. Its pan head provides strong surface contact, while its sharp point allows easy penetration without pre-drilling."
        )
    },
    14: {
        "name": "Self-Tapping Screw",
        "type": "Screw",
        "material": "Hardened Steel",
        "size": "M5",
        "head_type": "Flat Head",
        "drive_type": "Phillips Drive",
        "thread_type": "Self-Tapping",
        "strength_grade": "Grade 5",
        "coating": "Uncoated (Hardened Steel)",
        "application": "Metal and plastic fastening without pre-drilling.",
        "description": (
            "A self-tapping screw made from hardened steel, designed to drill its own threads in thin metal or plastic. Ideal for construction, "
            "automotive, and household repair, this screw eliminates the need for pre-drilling, making it a time-efficient choice for quick installations."
        )
    }
}

# Function to analyze an image
def analyze_screw_image(image):
    """
    Analyze an image using basic feature detection (edge detection).
    """
    # Convert the PIL image to OpenCV format
    img_cv = np.array(image)
    gray = cv2.cvtColor(img_cv, cv2.COLOR_RGB2GRAY)

    # Use Canny edge detection to find edges
    edges = cv2.Canny(gray, threshold1=50, threshold2=150)

    # Detect contours in the image
    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Analyze contours to classify head or drive type
    contour_count = len(contours)

    # Example classification based on contour count
    if contour_count > 50:
        return 9  # Torx Screw
    elif contour_count > 20:
        return 10  # Phillips Screw
    else:
        return 1  # Long Lag Screw (default)

# Function to analyze a video
def analyze_video(video_bytes):
    """
    Analyze a video to classify the screw based on frame analysis.
    """
    # Save the video temporarily
    temp_video_path = "/tmp/uploaded_video.mp4"
    with open(temp_video_path, "wb") as f:
        f.write(video_bytes)

    cap = cv2.VideoCapture(temp_video_path)
    frame_interval = 10  # Analyze every 10th frame
    frame_count = 0
    predictions = []

    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break

        if frame_count % frame_interval == 0:
            # Convert frame to PIL Image
            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            frame_image = Image.fromarray(frame_rgb)

            # Analyze the frame
            prediction = analyze_screw_image(frame_image)
            predictions.append(prediction)

        frame_count += 1

    cap.release()

    # Majority voting for final prediction
    if predictions:
        final_prediction = max(set(predictions), key=predictions.count)
        return final_prediction
    else:
        return None

# Callback function for file upload
def on_upload_change(change):
    """
    Callback function to handle file uploads for images or videos.
    """
    uploaded_file = list(change['new'].values())[0]
    file_content = uploaded_file['content']
    file_name = uploaded_file['metadata']['name']

    if file_name.lower().endswith(('.jpg', '.jpeg', '.png', '.bmp', '.tiff')):
        # Process as an image
        img = Image.open(BytesIO(file_content))
        plt.imshow(img)
        plt.axis('off')
        plt.show()

        # Analyze the image
        category_id = analyze_screw_image(img)
    elif file_name.lower().endswith(('.mp4', '.avi', '.mov', '.mkv')):
        # Process as a video
        print("Processing video, please wait...")
        category_id = analyze_video(file_content)
    else:
        print("Unsupported file format!")
        return

    # Fetch the screw information
    info = category_info.get(category_id, {"name": "Unknown", "type": "Unknown", "description": "No description available."})

    # Display the information
    print(f"Detected Screw Information:")
    print(f"  - Name: {info['name']}")
    print(f"  - Type: {info['type']}")
    print(f"  - Material: {info.get('material', 'Unknown')}")
    print(f"  - Size: {info.get('size', 'Unknown')}")
    print(f"  - Head Type: {info.get('head_type', 'Unknown')}")
    print(f"  - Drive Type: {info.get('drive_type', 'Unknown')}")
    print(f"  - Thread Type: {info.get('thread_type', 'Unknown')}")
    print(f"  - Strength Grade: {info.get('strength_grade', 'Unknown')}")
    print(f"  - Coating: {info.get('coating', 'Unknown')}")
    print(f"  - Application: {info.get('application', 'Unknown')}")
    print(f"  - Description: {info['description']}")

# Create a file upload widget
upload_widget = widgets.FileUpload(accept='image/*,video/*', multiple=False)

# Bind the callback function to the widget
upload_widget.observe(on_upload_change, names='value')

# Display the widget
print("Upload an image or video of the screw:")
display(upload_widget)
